-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParAuL where
import AbsAuL
import LexAuL
import ErrM
import Utils
import Data.Maybe
import Env

}

%name pProgram Program
%name pListPGlobl ListPGlobl
%name pPGlobl PGlobl
%name pBlock Block
%name pBlock BlockF
%name pListStm ListStm
%name pBasicType BasicType
%name pBoolean Boolean
%name pPtrVoid PtrVoid
%name pCompoundType CompoundType
%name pStm Stm
%name pEBlk EBlk
%name pDecl Decl
%name pVarInit VarInit
%name pArray Array
%name pVType VType
%name pListVType ListVType
%name pListArray ListArray
%name pLocal Local
%name pAss Ass
%name pFunc Func
%name pFuncWrite FuncWrite
%name pFuncRead FuncRead
%name pWhile While
%name pRepeat Repeat
%name pFor For
%name pIncrement Increment
%name pIf If
%name pElse Else
%name pElseIf ElseIf
%name pListElseIf ListElseIf
%name pReturn Return
%name pRValue RValue
%name pBreak Break
%name pListRExp ListRExp
%name pFuncD FuncD
%name pParamF ParamF
%name pListParamF ListParamF
%name pModality Modality
%name pLExp LExp
%name pListDim ListDim
%name pDim Dim
%name pRExp RExp
%name pRExp2 RExp2
%name pRExp3 RExp3
%name pRExp6 RExp6
%name pRExp7 RExp7
%name pRExp8 RExp8
%name pRExp9 RExp9
%name pRExp10 RExp10
%name pRExp11 RExp11
%name pRExp1 RExp1
%name pRExp4 RExp4
%name pRExp5 RExp5
%name pRExp12 RExp12
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '..' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '<=' { PT _ (TS _ 14) }
  '=' { PT _ (TS _ 15) }
  '==' { PT _ (TS _ 16) }
  '>' { PT _ (TS _ 17) }
  '>=' { PT _ (TS _ 18) }
  'Bool' { PT _ (TS _ 19) }
  'Char' { PT _ (TS _ 20) }
  'Float' { PT _ (TS _ 21) }
  'Int' { PT _ (TS _ 22) }
  'String' { PT _ (TS _ 23) }
  'Void' { PT _ (TS _ 24) }
  '[' { PT _ (TS _ 25) }
  ']' { PT _ (TS _ 26) }
  '^' { PT _ (TS _ 27) }
  'and' { PT _ (TS _ 28) }
  'break' { PT _ (TS _ 29) }
  'const' { PT _ (TS _ 30) }
  'do' { PT _ (TS _ 31) }
  'else' { PT _ (TS _ 32) }
  'elseif' { PT _ (TS _ 33) }
  'end' { PT _ (TS _ 34) }
  'false' { PT _ (TS _ 35) }
  'for' { PT _ (TS _ 36) }
  'function' { PT _ (TS _ 37) }
  'if' { PT _ (TS _ 38) }
  'in' { PT _ (TS _ 39) }
  'local' { PT _ (TS _ 40) }
  'name' { PT _ (TS _ 41) }
  'nil' { PT _ (TS _ 42) }
  'not' { PT _ (TS _ 43) }
  'or' { PT _ (TS _ 44) }
  'readChar' { PT _ (TS _ 45) }
  'readFloat' { PT _ (TS _ 46) }
  'readInt' { PT _ (TS _ 47) }
  'readString' { PT _ (TS _ 48) }
  'ref' { PT _ (TS _ 49) }
  'repeat' { PT _ (TS _ 50) }
  'res' { PT _ (TS _ 51) }
  'return' { PT _ (TS _ 52) }
  'then' { PT _ (TS _ 53) }
  'true' { PT _ (TS _ 54) }
  'until' { PT _ (TS _ 55) }
  'val' { PT _ (TS _ 56) }
  'valres' { PT _ (TS _ 57) }
  'while' { PT _ (TS _ 58) }
  'writeChar' { PT _ (TS _ 59) }
  'writeFloat' { PT _ (TS _ 60) }
  'writeInt' { PT _ (TS _ 61) }
  'writeString' { PT _ (TS _ 62) }
  '{' { PT _ (TS _ 63) }
  '}' { PT _ (TS _ 64) }
  '~=' { PT _ (TS _ 65) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_LIdent { PT _ (T_LIdent _) }

-- tipi per gli attributi di $$
%attributetype { AttrTree a }
%attribute res { Result }
%attribute parsetree { a }
%attribute vint { Integer }
%attribute vdbl { Double }
%attribute vchr { Char }
%attribute vstr { String }
%attribute vlident { LIdent }

-- attributi per il frontend
%attribute envin { EnvT }       -- env più esterno
%attribute envloc { EnvT }      -- env del blocco locale
%attribute envout { EnvT }      -- env del blocco uscente
%attribute errs { [String] }
%attribute posn { Posn }
%attribute tipo { CmpType }
%attribute listparf { [(ParamF,Posn,String)] }
%attribute parname { String }
%attribute lrexptpe { [CmpType] }

%%

Integer : L_integ  { $$.vint = (read ( $1)) :: Integer }
Double : L_doubl  {  $$.vdbl = (read ( $1)) :: Double }
String : L_quoted { $$.vstr = $1 }
Char : L_charac {  $$.vchr = (read ( $1)) :: Char }
LIdent : L_LIdent 
    {         
            $$.posn =  (tokenPosn $1)                           
            ; $$.vlident = LIdent (getLIdentT $1)
    }

Program : ListPGlobl
    { 
        $1.envin = emptyEnv
        ; $1.envloc = emptyEnv
        ; $$.res = Result (AbsAuL.Prog $1.parsetree ) "qui TAC" $1.envout $1.errs
    }

ListPGlobl : PGlobl 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = (:[]) $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    } 
    | PGlobl ListPGlobl
    { 
        $1.envin = $$.envin
        ; $2.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $2.envloc = $1.envout
        ; $$.parsetree = (:) $1.parsetree $2.parsetree
        ; $$.envout = $2.envout
        ; $$.errs = $1.errs ++ $2.errs
        
    }

PGlobl : Stm 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.ProgGlobB $1.parsetree
        ; $$.envout = $1.envout 
        ; $$.errs = $1.errs
    }
       | FuncD 
    { 
        $$.parsetree = AbsAuL.ProgGlobF $1.parsetree
        ; $1.envloc = $$.envloc
        ; $1.envin = $$.envin 
        ; $$.envout = $1.envout 
        ; $$.errs = $1.errs
    }

--  ========================
--  =======  BLKS  =========
--  ========================

Block : ListStm 
    { 
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $1.envloc = if (isJust (lookupEnv "return" $$.envloc))
                         then (reinsertRetEnv 
                                ((getTypeR . fromJust) (lookupEnv "return" $$.envloc))
                                ((foundIstr . fromJust) (lookupEnv "return" $$.envloc))
                                emptyEnv)
                         else emptyEnv
        ; $$.parsetree = AbsAuL.Blk $1.parsetree
        ; $$.envout = if (isJust (lookupEnv "return" $$.envloc))
                         then (reinsertRetEnv 
                                    ((getTypeR . fromJust) (lookupEnv "return" $1.envout))
                                    ((foundIstr . fromJust) (lookupEnv "return" $1.envout))
                                    $$.envloc)
                         else $$.envloc
        ; $$.errs = $1.errs
        
    }
-- N.d.R.: Per necessità di non switchare il envloc ed envin dichiaro una regola
-- fittizia al fine di ottenere il medesimo tipo e non stravolgere l'AST
BlockF : ListStm 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.Blk $1.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = (if (isJust (lookupEnv "return" $1.envout))
                    then (if (((getTypeR . fromJust) (lookupEnv "return" $1.envout)) == ErrT)
                             then []
                             else (if ((foundIstr . fromJust) (lookupEnv "return" $1.envout))
                                    then []
                                    else ["error: statement return not found in function definition!"]))
                    else ["Compiler Frontend General Error: listen to me, you must go to sleep..."]) ++ $1.errs
        
    }
ListStm : {- empty -} 
    { 
        $$.parsetree = [] 
        ; $$.envout = $$.envloc
        ; $$.errs = []
    } 
    | ListStm Stm
    { 
        $1.envin = $$.envin
        ; $2.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $2.envloc = $1.envout
        ; $$.parsetree =  flip (:) $1.parsetree $2.parsetree
        ; $$.envout = $2.envout
        ; $$.errs = $1.errs ++ $2.errs
    }

--  ========================
--  ======= TIPI   =========
--  ========================

BasicType : 'Bool' 
    { 
        $$.parsetree = AbsAuL.BasicType_Bool 
    }
    | 'Char' 
    { 
        $$.parsetree = AbsAuL.BasicType_Char 
    }
    | 'Float' 
    { 
        $$.parsetree = AbsAuL.BasicType_Float 
    }
    | 'Int' 
    { 
        $$.parsetree = AbsAuL.BasicType_Int 
    }
    | 'String' 
    { 
        $$.parsetree = AbsAuL.BasicType_String 
    }
    | 'Void' 
    { 
        $$.parsetree = AbsAuL.BasicType_Void 
    }

Boolean : 'true' { $$.parsetree = AbsAuL.Boolean_true }
        | 'false' { $$.parsetree = AbsAuL.Boolean_false }

PtrVoid : 'nil' { $$.parsetree = AbsAuL.PtrType }

CompoundType : BasicType { $$.parsetree =  AbsAuL.CompTypeB $1.parsetree }
             | '*' CompoundType { $$.parsetree =  AbsAuL.CompTypeP $2.parsetree }
             | BasicType ListBracks { $$.parsetree =  AbsAuL.CompTypeA $1.parsetree $2.parsetree }

Bracks : '[' ']' { $$.parsetree = AbsAuL.Brack }

ListBracks : Bracks { $$.parsetree =  (:[]) $1.parsetree } 
             | Bracks ListBracks { $$.parsetree =  (:) $1.parsetree $2.parsetree }

--  ========================
--  =======  STM   =========
--  ========================

Stm : Decl ';' 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SDecl $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | Local ';' 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SLocal $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | Ass ';' 
    { 
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $$.parsetree = AbsAuL.SAss $1.parsetree 
        ; $$.envout = $$.envloc
        ; $$.errs = $1.errs
    }
    | While 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SWhile $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | Repeat ';' 
    {
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc 
        ; $$.parsetree = AbsAuL.SRepeat $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs 
    }
    | For 
    {
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SFor $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
    }
    | If 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SIf $1.parsetree 
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
    }
    | Func ';' 
    { 
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $$.parsetree = AbsAuL.SRExp $1.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = $1.errs
    }
    | EBlk 
    {
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SEBlk $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | Return ';'
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SReturn $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | Break ';' 
    { 
        $$.parsetree = AbsAuL.SBreak $1.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = []
    }

--  ========================
--  =======  EBLK  =========
--  ========================
EBlk : 'do' Block 'end' 
    { 
        $2.envin = $$.envin
        ; $2.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.EBlkS $2.parsetree
        ; $$.errs = $2.errs
        ; $$.envout = $2.envout
    }

--  ========================
--  =======  DECL  =========
--  ========================
Decl : BasicType LExp VarInit 
    { 
        $2.envin = (mergeEnv $$.envloc $$.envin)
        ; $3.envin = (mergeEnv $$.envloc $$.envin)
        ; $3.tipo = makeCmpType (getPtrLev $2.parsetree) (getArrLev $2.parsetree) $1.parsetree
        ; $$.parsetree = AbsAuL.DeclSP $1.parsetree $2.parsetree $3.parsetree
        ; $$.envout = ( if (isOk (insertEnv $1.parsetree Modality1 $2.parsetree $$.envloc $2.posn))
                         then (fromOk (insertEnv $1.parsetree Modality1 $2.parsetree $$.envloc $2.posn))
                         else $$.envloc)
        ; $$.errs = ( if (isJust (lookupEnv ( (fromLIdent . getLIdentlexp) $2.parsetree) $$.envloc))
                         then ["error at "++ (showFromPosn $2.posn) ++": variable " ++ 
                                (fromBad (insertEnv $1.parsetree Modality1 $2.parsetree $$.envloc $2.posn))]
                         else []
                        ) ++ $2.errs ++ $3.errs
                            
    }

VarInit : {- empty -}
    { 
        
        $$.parsetree = AbsAuL.VarINil
        ; $$.errs = []
        ; $$.tipo = Base BasicType_Void
    }
    | '=' RExp 
    {
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.VarExp $2.parsetree 
        ; $$.errs = (if (not ($2.tipo == ErrT))
                        then if (compCmpType $$.tipo $2.tipo) == ErrT
                                then ["error at "++ ((showFromPosn . tokenPosn) $1) ++ ": cannot assign '" ++ (showCmpType $2.tipo) ++
                                        "' to a variable with type '"++(showCmpType $$.tipo)++"'"]
                                else []
                        else [])++ $2.errs
    }
    | '=' Array 
    { 
        $$.parsetree = AbsAuL.VarMat $2.parsetree
        ; $$.errs  = (controlArrTipo $$.tipo $2.parsetree $1)
    }


Array : '{' ListArray '}'
    { 
        $$.parsetree = AbsAuL.ArrayV0 $2.parsetree 
    }
    | '{' ListVType '}' 
    { 
        $$.parsetree = AbsAuL.ArrayV1 $2.parsetree 
    }
VType : Boolean 
    { 
        $$.parsetree = AbsAuL.VTypeBoolean $1.parsetree 
    }
    | Char --modded
    { 
        $$.parsetree = AbsAuL.VTypeChar $1.vchr 
    }
    | Double --modded
    { 
        $$.parsetree = AbsAuL.VTypeDouble $1.vdbl 
    }
    | Integer --modded
    { 
        $$.parsetree = AbsAuL.VTypeInteger $1.vint
    }
    | String --modded
    { 
        $$.parsetree = AbsAuL.VTypeString $1.vstr 
    }
    | PtrVoid 
    { 
        $$.parsetree = AbsAuL.VTypePtrVoid $1.parsetree 
    }
ListVType : VType 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    } 
    | VType ',' ListVType 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree 
    }
ListArray : Array 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    } 
    | Array ',' ListArray 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree
    }

--  ========================
--  =======  LOCL  =========
--  ========================

Local : 'local' Decl 
    { 
        $2.envin = (mergeEnv $$.envloc $$.envin)
        ; $2.envloc = emptyEnv
        ; $$.parsetree = AbsAuL.DeclLocal $2.parsetree 
        ; $$.envout = (mergeEnv $2.envout $$.envloc)
        ; $$.errs = $2.errs
    }

--  ========================
--  =======  ASSG  =========
--  ========================

Ass : LExp '=' RExp
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.AssD $1.parsetree $3.parsetree
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                        then if ((not . isFnctEnv . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                then (downCmpType (getPtrLev $1.parsetree) (getArrLev $1.parsetree)
                                        ((fst . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin)))
                                else ErrT 
                        else ErrT)
        ; $$.errs = (if ($$.tipo == ErrT)
                         then (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                 then (if ((not . isFnctEnv . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                          then ["error at "++ ((showFromPosn . tokenPosn) $2) ++": dereferencing level is inadequate!"]
                                          else ["error at "++ ((showFromPosn . tokenPosn) $2) ++": cannot assign value to a function!"])
                                 else ["error at "++ ((showFromPosn . tokenPosn) $2) ++": refer to unexistent variable!"])
                         else if (not ((compCmpType $$.tipo $3.tipo) == ErrT))
                                  then if((snd . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin) == Modality_const)
                                         then ["error at " ++ ((showFromPosn . tokenPosn) $2) ++
                                               ": cannot assign value to a constant variable "++
                                               ((fromLIdent . getLIdentlexp) $1.parsetree) ++"!"]
                                         else []
                                  else ["error at " ++ ((showFromPosn . tokenPosn) $2) ++ 
                                        ": expects argument of type '" ++ (showCmpType $$.tipo) ++ 
                                        "' but has type '"++ (showCmpType $3.tipo) ++"'"]) ++ $1.errs ++ $3.errs
    }
    
--  ========================
--  =======  FUNC  =========
--  ========================

Func : FuncWrite 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsAuL.FuncBW $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = Base BasicType_Void
    }
    | FuncRead 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsAuL.FuncBR $1.parsetree 
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }
    | LIdent '(' ListRExp ')' --modded -> controllare tipo ritorno
    { 
        $$.parsetree = AbsAuL.FnctCall $1.vlident $3.parsetree
        ; $3.envin = $$.envin
        ; $$.tipo = if (isJust (lookupEnv (fromLIdent $1.vlident) $$.envin))
                        then (if ((isFnctEnv . fromJust) (lookupEnv (fromLIdent $1.vlident) $$.envin))
                              then ((getTypeF . fromJust) (lookupEnv (fromLIdent $1.vlident) $$.envin))
                              else ErrT)
                        else ErrT
        ; $$.errs = (if (isJust (lookupEnv (fromLIdent $1.vlident) $$.envin))
                        then (if ((isFnctEnv . fromJust) (lookupEnv (fromLIdent $1.vlident) $$.envin))
                              then (controlFnctTipo
                                        (map (\x -> (fst . getType) x) 
                                            ((getParamF . fromJust) (lookupEnv (fromLIdent $1.vlident) $$.envin)))
                                        $3.lrexptpe
                                        $1.posn
                                   )
                              else ["error at "++(showFromPosn $1.posn)++": "++(fromLIdent $1.vlident)++"isn't defined as function!"])
                        else ["error at "++(showFromPosn $1.posn)++": function "++(fromLIdent $1.vlident)++"is undefined!"]) ++ $3.errs
    }
ListRExp : {- empty -} 
    { 
        $$.parsetree = []
        ; $$.lrexptpe = []
        ; $$.errs = []
    }
    | RExp 
    { 
        $$.parsetree = (:[]) $1.parsetree
        ; $1.envin = $$.envin
        ; $$.lrexptpe = (:[]) $1.tipo
        ; $$.errs = $1.errs
    }
    | RExp ',' ListRExp 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree
        ; $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.lrexptpe = (:) $1.tipo $3.lrexptpe
        ; $$.errs = $1.errs ++ $3.errs
    }

FuncWrite : 'writeInt' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.WriteI $3.parsetree
        ; $$.errs = (if (not($3.tipo == Base BasicType_Int))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeInt' need to be Int!"]
                        else []
                     ) ++ $3.errs
    }
    | 'writeFloat' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.WriteF $3.parsetree
        ; $$.errs = (if (not ($3.tipo == Base BasicType_Float))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeFloat' need to be Float!"]
                        else []
                     ) ++ $3.errs
    }
    | 'writeChar' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.WriteC $3.parsetree
        ; $$.errs = (if (not ($3.tipo == Base BasicType_Char))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeChar' need to be Char!"]
                        else []
                     ) ++ $3.errs
    }
    | 'writeString' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.WriteS $3.parsetree
        ; $$.errs = (if (not ($3.tipo == Base BasicType_String))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeString' need to be String!"]
                        else []
                     ) ++ $3.errs
    }

FuncRead : 'readInt' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadI
        ; $$.tipo = Base BasicType_Int
        ; $$.errs = []
    }
    | 'readFloat' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadF
        ; $$.tipo = Base BasicType_Float
        ; $$.errs = []
    }
    | 'readChar' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadC
        ; $$.tipo = Base BasicType_Char
        ; $$.errs = []
    }
    | 'readString' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadS
        ; $$.tipo = Base BasicType_String
        ; $$.errs = []
    }

--  ========================
--  =======  WHLE  =========
--  ========================

While : 'while' RExp EBlk 
    { 
        $2.envin = mergeEnv $$.envloc $$.envin
        ; $3.envin = $$.envin
        ; $3.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.LoopW $2.parsetree $3.parsetree
        ; $$.envout = $3.envout
        ; $$.errs = (if (op2CompType EqO (Base BasicType_Bool) $2.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": 'while' condition need to be 'Bool' expression!"]
                        else []) ++ $2.errs ++ $3.errs
    }

--  ========================
--  =======  REPT  =========
--  ========================

Repeat : 'repeat' Block 'until' RExp 
    { 
        $2.envin = $$.envin
        ; $2.envloc = $$.envloc
        ; $4.envin = mergeEnv $$.envloc $$.envin
        ; $$.parsetree = AbsAuL.LoopR $2.parsetree $4.parsetree
        ; $$.envout = $2.envout
        ; $$.errs = (if (op2CompType EqO (Base BasicType_Bool) $4.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": 'repeat' condition need to be 'Bool' expression!"]
                        else []) ++ $2.errs ++ $4.errs
    }

--  ========================
--  =======  FORS  =========
--  ========================

For : 'for' LIdent '=' RExp ',' RExp Increment EBlk --modded
    { 
        $4.envin = mergeEnv $$.envloc $$.envin
        ; $6.envin = mergeEnv $$.envloc $$.envin
        ; $7.envin = mergeEnv $$.envloc $$.envin
        
        ; $8.envin = $$.envin
        ; $8.envloc = if((all (\(x,y) -> x == y ) [($4.tipo,$6.tipo),($6.tipo,$7.tipo),($7.tipo,$4.tipo)]) )
                        then (mergeEnv (fromOk (insertEnv (getBaseType $7.tipo) Modality1 (LExpS $2.vlident) emptyEnv $2.posn)) $$.envloc)
                        else (mergeEnv (fromOk (insertEnv (getBaseType $4.tipo) Modality1 (LExpS $2.vlident) emptyEnv $2.posn)) $$.envloc)
        ; $$.parsetree = AbsAuL.LoopF $2.vlident $4.parsetree $6.parsetree $7.parsetree $8.parsetree
        ; $$.envout = $8.envout
        ; $$.errs = (if ( all (\(x,y) -> x == y ) [($4.tipo,$6.tipo),($6.tipo,$7.tipo),($7.tipo,$4.tipo)])
                        then []
                        else ["error at "++ (showFromPosn $2.posn) ++": incompatible types in 'for' loop conditions!"])
                               ++ $4.errs ++ $6.errs ++ $7.errs ++ $8.errs
    }
    | 'for' LIdent 'in' LIdent EBlk --modded
    { 
        $$.parsetree = AbsAuL.LoopFE $2.vlident $4.vlident $5.parsetree 
    }
Increment : {- empty -} -- per l'appunto, assumiamo sia 1 l'incremento
    { 
        $$.parsetree = AbsAuL.FIncE
        ; $$.tipo = Base BasicType_Int
        ; $$.errs = []
    }
    | ',' RExp 
    { 
        $$.parsetree = AbsAuL.FInc $2.parsetree
        ; $$.tipo = $2.tipo
        ; $$.errs = $2.errs
    }
    
--  ========================
--  =======   IF   =========
--  ========================
If : 'if' RExp 'then' Block ListElseIf Else 'end'
    { 
        $2.envin = mergeEnv $$.envloc $$.envin
        ; $4.envin = $$.envin
        ; $5.envin = $$.envin
        ; $6.envin = $$.envin
        ; $4.envloc = $$.envloc
        ; $5.envloc = $4.envout
        ; $6.envloc = $5.envout
        ; $$.parsetree = AbsAuL.IfM $2.parsetree $4.parsetree (reverse $5.parsetree) $6.parsetree
        ; $$.envout = $6.envout
        ; $$.errs = (if (op2CompType EqO (Base BasicType_Bool) $2.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": 'if' condition need to be 'Bool' expression!"]
                        else []) ++ $2.errs ++ $4.errs ++ $5.errs ++ $6.errs
    }

Else : 'else' Block 
    { 
        $2.envin = $$.envin
        ; $2.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.ElseS $2.parsetree
        ; $$.errs = $2.errs
        ; $$.envout = $2.envout
    }
    | {- empty -} 
    { 
        $$.parsetree = AbsAuL.ElseE
        ; $$.envout = $$.envloc
        ; $$.errs = []
    }

ElseIf : 'elseif' RExp 'then' Block 
    { 
        $2.envin = mergeEnv $$.envloc $$.envin
        ; $4.envin = $$.envin
        ; $4.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.ElseIfD $2.parsetree $4.parsetree
        ; $$.envout = $4.envout
        ; $$.errs = (if (op2CompType EqO (Base BasicType_Bool) $2.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": 'elseif' condition need to be 'Bool' expression!"]
                        else []) ++ $2.errs ++ $4.errs
    }

ListElseIf : {- empty -} 
    { 
        $$.parsetree = []
        ; $$.envout = $$.envloc
        ; $$.errs = [] 
    }
    | ListElseIf ElseIf 
    { 
        $1.envin = $$.envin
        ; $2.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $2.envloc = $1.envout
        ; $$.envout = $2.envout
        ; $$.parsetree = flip (:) $1.parsetree $2.parsetree
        ; $$.errs = $1.errs ++ $2.errs
    }

--  ========================
--  =======  JUMP  =========
--  ========================

Return : 'return' RValue 
    {
        $$.parsetree = AbsAuL.JumpR $2.parsetree 
        ; $2.envin = $$.envin
        ; $2.envloc = $$.envloc
        ; $2.posn = (tokenPosn $1)
        ; $$.envout = if (isJust (lookupEnv "return" $$.envloc))
                         then (reinsertRetEnv ((getTypeR . fromJust) (lookupEnv "return" $$.envloc)) True $$.envloc)
                         else $$.envloc
        ; $$.errs = $2.errs
    }

RValue : {- empty -} 
    { 
        $$.parsetree = AbsAuL.JumpRE
        ; $$.errs = if (isJust (lookupEnv "return" $$.envloc))
                        then (if (((getTypeR . fromJust) (lookupEnv "return" $$.envloc)) == ErrT)
                                then []
                                else ["error at "++ (showFromPosn $$.posn) ++ ": empty return, but need '"++
                                      (showCmpType ((getTypeR . fromJust) (lookupEnv "return" $$.envloc))) ++
                                      "' expression type!"] )
                        else ["error at " ++ (showFromPosn $$.posn) ++ ": return statement out of function!"]
    }
    | RExp 
    { 
        $$.parsetree = AbsAuL.JumpRV $1.parsetree
        ; $1.envin = mergeEnv $$.envloc $$.envin
        ; $$.errs = (if (isJust (lookupEnv "return" $$.envloc))
                        then (if ((getTypeR . fromJust) (lookupEnv "return" $$.envloc) == ErrT)
                                 then ["error at " ++ (showFromPosn $$.posn) ++ ": return is Void, but given expression's type is '" ++
                                        (showCmpType $1.tipo) ++ "'"]
                                 else (if ((==) 
                                            (compCmpType ((getTypeR . fromJust) (lookupEnv "return" $$.envloc)) $1.tipo)
                                            ((getTypeR . fromJust) (lookupEnv "return" $$.envloc)))
                                          then []
                                          else ["error at "++ (showFromPosn $$.posn) ++ ": return need '"++ 
                                                (showCmpType ((getTypeR . fromJust) (lookupEnv "return" $$.envloc))) ++
                                                "', but given '"++ (showCmpType $1.tipo) ++ "' expression type!"]))
                        else ["error at " ++ (showFromPosn $$.posn) ++ ": return statement out of function!"]) ++ $1.errs
    }


Break : 'break' 
    { 
        $$.parsetree = AbsAuL.JumpB 
    }

--  ========================
--  =======  FUND  =========
--  ========================
-- if $7.envin; se bad vuol dire che è già dichiarata, ma se la funzione viene
-- utilizzata correttamente nella "nuova" dichiarazione non vedo perchè deve 
-- dare errori nelle chiamate interne alla funzione stessa!
FuncD : CompoundType 'function' LIdent '(' ListParamF ')' BlockF 'end'
    { 
        $$.parsetree = AbsAuL.FnctDecl $1.parsetree $3.vlident $5.parsetree $7.parsetree
        ; $7.envloc = insertRetEnv $1.parsetree False (bypassEnvLoc $5.listparf)
        ; $7.envin = if (isOk (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))
                         then (mergeEnv (fromOk (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))
                                       $$.envin)
                         else (mergeEnv (mergeEnv 
                                            (fromOk (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn emptyEnv))
                                            $$.envloc) 
                                        $$.envin)
        ; $$.envout = if (isOk (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))
                         then (fromOk (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))
                         else $$.envloc
        ; $$.errs = (if (isBad (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))
                         then [(fromBad (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))]
                         else []) ++ $7.errs
         
    }
ParamF : Modality BasicType LExp 
    { 
        $$.parsetree = AbsAuL.ParmDeclF $1.parsetree $2.parsetree $3.parsetree
        ; $$.posn = $3.posn
        ; $$.parname = (fromLIdent . getLIdentlexp) $3.parsetree
    }
ListParamF : {- empty -} 
    { 
        $$.parsetree = []
        ; $$.listparf = []
    }
    | ParamF 
    { 
        $$.parsetree = (:[]) $1.parsetree
        ; $$.listparf = [($1.parsetree,$1.posn,$1.parname)]
    }
    | ParamF ',' ListParamF 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree
        ; $$.listparf = (:) ($1.parsetree,$1.posn,$1.parname) $3.listparf
    }
Modality : {- empty -} 
    { 
        $$.parsetree = AbsAuL.Modality1 
    }
    | 'val' 
    { 
        $$.parsetree = AbsAuL.Modality_val
    }
    | 'ref' -- $$.parsetree = AbsAuL.Modality_ref
    { 
        $$.parsetree = AbsAuL.Modality1
    }
    | 'const' 
    { 
        $$.parsetree = AbsAuL.Modality_const 
    }
    | 'res' 
    { 
        $$.parsetree = AbsAuL.Modality_res 
    }
    | 'valres' 
    { 
        $$.parsetree = AbsAuL.Modality_valres 
    }
    | 'name' 
    { 
        $$.parsetree = AbsAuL.Modality_name 
    }
--  ========================
--  =======  LEXP  =========
--  ========================
LExp : LIdent
    {
        $$.parsetree = AbsAuL.LExpS $1.vlident
        ; $$.posn = $1.posn
        ; $$.errs = []
    }
    | '*' LExp 
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.LExpDR $2.parsetree 
        ; $$.posn = $2.posn
        ; $$.errs = $2.errs
    }
    | LIdent ListDim
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.LExpA $1.vlident $2.parsetree
        ; $$.posn = $1.posn
        ; $$.errs = $2.errs
    }

ListDim : Dim 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = (:[]) $1.parsetree 
        ; $$.errs = $1.errs
    } 
    | Dim ListDim 
    { 
        $1.envin = $$.envin
        ; $2.envin = $$.envin
        ; $$.parsetree = (:) $1.parsetree $2.parsetree
        ; $$.errs = $1.errs ++ $2.errs
    }

Dim : '[' RExp ']' --VARA CHE GNOCCA STA COMPARAZIONE!!
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.Dims $2.parsetree
        ; $$.errs = if (op2CompType EqO $2.tipo (Base BasicType_Int)) == ErrT
                       then ["error at "++ ((showFromPosn . tokenPosn) $1) ++ ": type for arrays referencing need to be 'Int'!"]
                       else []
    }

--  ========================
--  =======  REXP  =========
--  ========================


RExp : RExp 'or' RExp1 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Or $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType OrO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for 'or' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool 
    }
    | RExp1 'and' RExp2 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.And $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType AndO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for 'and' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool
    }
    | RExp1 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp2 : 'not' RExp3 
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.Not $2.parsetree
        ; $$.errs = (if (not ((op1CompType NotO $2.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $1) ++ ": type need to be compatible in 'not' operations!"]) ++ $2.errs
        ; $$.tipo = Base BasicType_Bool
    } 
    | RExp3 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp3 : RExp3 '==' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Eq $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType EqO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '==' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool 
    }
    | RExp3 '~=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Neq $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType NeqO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '~=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool 
    }
    | RExp3 '<' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Lt $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType LtO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '<' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool
    }
    | RExp3 '<=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.LtE $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType LtEO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '<=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool
    }
    | RExp3 '>' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Gt $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType GtO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '>' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool
    }
    | RExp3 '>=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.GtE $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType GtEO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '>=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool
    }
    | RExp4 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp6 : RExp6 '+' RExp7 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Add $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType AddO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": '+' arguments' types need to be Int, Float or Char!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((op2CompType AddO $1.tipo $3.tipo) == ErrT) 
                         then (Base BasicType_Float)
                         else (op2CompType AddO $1.tipo $3.tipo) )  
    }
    | RExp6 '-' RExp7 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Sub $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType SubO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": '-' arguments' types need to be Int, Float or Char!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((op2CompType SubO $1.tipo $3.tipo) == ErrT) 
                         then (Base BasicType_Float)
                         else (op2CompType SubO $1.tipo $3.tipo) )  
    }
    | RExp7 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp7 : RExp7 '*' RExp8 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Mul $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType MulO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": '*' arguments' types need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((op2CompType MulO $1.tipo $3.tipo) == ErrT) 
                         then (Base BasicType_Float)
                         else (op2CompType MulO $1.tipo $3.tipo) ) 
    }
    | RExp7 '/' RExp8 
    {
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Div $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType DivO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": '/' arguments' types need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((op2CompType DivO $1.tipo $3.tipo) == ErrT) 
                         then (Base BasicType_Float)
                         else (op2CompType DivO $1.tipo $3.tipo) )
    }
    | RExp7 '%' RExp8 
    {   
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Rem $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType RemO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": '%' arguments' types need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = (Base BasicType_Int)
    }
    | RExp8 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp8 : RExp9 '^' RExp8 
    {   
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Pow $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType PowO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((op2CompType PowO $1.tipo $3.tipo) == ErrT) 
                         then (Base BasicType_Float)
                         else (op2CompType PowO $1.tipo $3.tipo) )
    } 
    | RExp9 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }
RExp9 : '-' RExp10
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.Neg $2.parsetree
        ; $$.errs = (if (not ((op1CompType NeqO $2.tipo) == ErrT))
                         then []
                         else ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": in negation operator type need to be 'Int' or 'Float'!"]   ) ++ $2.errs
        ; $$.tipo = if (op1CompType NegO $2.tipo) == ErrT
                         then (Base BasicType_Float)
                         else (op1CompType NeqO $2.tipo)
    } 
    | RExp10 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp10 : Func
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsAuL.FCall $1.parsetree
        ; $$.tipo = if (($1.tipo == (Base BasicType_Void)) || $1.tipo == ErrT)
                        then ErrT
                        else $1.tipo
        ; $$.errs = (if (($1.tipo == (Base BasicType_Void)) || $1.tipo == ErrT)
                        then ["error in RExp10: cannot use a 'Void' function in expression!"]
                        else []) ++ $1.errs
    }
    | RExp10 '..' RExp11
    {
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.FStrCnt $1.parsetree $3.parsetree
        ; $$.tipo = op2CompType ConcatO $1.tipo $3.tipo
        ; $$.errs = (if (op2CompType ConcatO $1.tipo $3.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $2) ++": '..' need to have 'Char'(s) or 'String'(s) as arguments!"]
                        else []) ++ $1.errs ++ $3.errs 
        
    }
    | '#' RExp11
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.FLen $2.parsetree
        ; $$.tipo = op1CompType SizeO $2.tipo
        ; $$.errs = (if (op1CompType SizeO $2.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": '#' need to have Arrays or Pointer as argument!"]
                        else []) ++ $2.errs 
    }
    | RExp11 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }

RExp11 : Integer
    { 
        $$.parsetree = AbsAuL.ValInt $1.vint
        ; $$.tipo = Base BasicType_Int
        ; $$.envout = $$.envin
        ; $$.errs = []
    }
    | LExp
    { 
        $$.parsetree = AbsAuL.ValVariable $1.parsetree 
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                        then (if (isFnctEnv (fromJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin)))
                                then ErrT
                                else (downCmpType (getPtrLev $1.parsetree) (getArrLev $1.parsetree)
                                        ((fst . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))))
                        else ErrT )
        ; $$.errs = (if (isNothing (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                        then ["error: reference to " ++ ((fromLIdent . getLIdentlexp) $1.parsetree) ++ " at line " ++
                                (showFromPosn $1.posn) ++ " is invalid (maybe a function or not declared variable?)"]
                        else ( if (not (isFnctEnv (fromJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))))
                                   then (if ((downCmpType (getPtrLev $1.parsetree) (getArrLev $1.parsetree)
                                              ((fst . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))) == ErrT)
                                            then ["error at "++ (showFromPosn $1.posn) ++": invalid dereferencing (maybe too much?) referring to '"++ 
                                                    ((fromLIdent . getLIdentlexp) $1.parsetree) ++"'"]
                                            else []) 
                                   else ["error at "++ (showFromPosn $1.posn) ++": cannot use a function as a variable!"])
                             ) ++ $1.errs
    }
    | '&' LExp 
    { 
        $$.parsetree = AbsAuL.ValRef $2.parsetree
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                        then (if (not (isFnctEnv (fromJust (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))))
                                 then (addPtrT ( downCmpType (getPtrLev $2.parsetree) (getArrLev $2.parsetree)
                                        ((fst . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))))
                                 else ErrT)
                        else ErrT )
        ; $$.errs = (if (isNothing (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                        then ["error: reference to " ++ ((fromLIdent . getLIdentlexp) $2.parsetree) ++ " at line " ++
                                (showFromPosn $2.posn) ++ "is invalid (maybe a function or not declared variable?)"]
                        else (if (not (isFnctEnv (fromJust (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))))
                                then (if ((addPtrT ( downCmpType (getPtrLev $2.parsetree) (getArrLev $2.parsetree)
                                                ((fst . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin)))) == ErrT)
                                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": too many dereferencing refering to '"
                                                ++ ((fromLIdent . getLIdentlexp) $2.parsetree) ++"'"]
                                        else [] )
                                else ["error at "++ (showFromPosn $2.posn) ++": cannot use a function as a variable!"])) ++ $2.errs
    }
    | Double --modded
    { 
        $$.parsetree = AbsAuL.ValDouble $1.vdbl
        ; $$.tipo = Base BasicType_Float
        ; $$.errs = []
    }
    | String --modded
    { 
        $$.parsetree = AbsAuL.ValString $1.vstr
        ; $$.tipo = Base BasicType_String
        ; $$.errs = []
    }
    | Char --modded
    { 
        $$.parsetree = AbsAuL.ValChar $1.vchr
        ; $$.tipo = Base BasicType_Char
        ; $$.errs = []
    }
    | Boolean 
    { 
        $$.parsetree = AbsAuL.ValBoolean $1.parsetree
        ; $$.tipo = Base BasicType_Bool
        ; $$.errs = []
    }
    | PtrVoid 
    { 
        $$.parsetree = AbsAuL.ValPtr $1.parsetree
        ; $$.tipo = Base BasicType_Void
        ; $$.errs = []
    }
    | RExp12 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree 
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }

RExp1 : RExp2 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }
RExp4 : RExp5 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp5 : RExp6 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp12 : '(' RExp ')' 
    { 
        $2.envin = $$.envin
        ; $$.parsetree = $2.parsetree
        ; $$.errs = $2.errs
        ; $$.tipo = $2.tipo 
    }

{

data Result = Result Program String EnvT [String]  deriving (Eq, Show)


controlArrTipo :: CmpType -> Array -> Token -> [String]
controlArrTipo ts arr tok
    | (isArrT ts) && (not (isPtrT ts)) = if (checkTypeInit (getBaseType ts) arr)
                                            then if (sameLenChk (getArrTLev ts) arr)
                                                    then []
                                                    else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                                          ": array initialization hasn't same "++
                                                          "deferencing level of type definition (" ++ 
                                                          (show (getArrTLev ts)) ++")!"]
                                            else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                                  ": array initialization isn't of the same type of " ++
                                                  "variable type ('"++ (showCmpType (Base (getBaseType ts))) ++"')!"]
    | (isArrT ts) && (isPtrT ts) = if (checkTypeInit BasicType_Void arr)
                                      then if (sameLenChk (getArrTLev ts) arr)
                                              then []
                                              else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                                    ": array initialization hasn't same "++
                                                    "deferencing level of type definition (" ++ 
                                                    (show (getArrTLev ts)) ++")!"]
                                      else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                            ": array initialization isn't of the same type of " ++
                                            "variable type ('"++ (showCmpType  ts) ++"')!"]
    | (not (isArrT ts)) && (isPtrT ts) = let nts = makeCmpType  0 (getPtrTLev ts) (getBaseType ts)
                                         in if (checkTypeInit (getBaseType nts) arr)
                                                then if (sameLenChk (getArrTLev nts) arr)
                                                        then []
                                                        else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                                              ": array initialization hasn't same "++
                                                              "deferencing level of type definition (" ++ 
                                                              (show (getArrTLev ts)) ++")!"]
                                                else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                                      ": array initialization isn't of the same type of " ++
                                                      "variable type ('"++ (showCmpType (Base (getBaseType ts))) ++"')!"]

controlFnctTipo' :: [CmpType] -> [CmpType] -> [String]
controlFnctTipo' ps rexps = foldr (\(te,tr,pn) xs -> (cmpType te tr pn) ++ xs) [] (zip3 ps rexps [1..])
    where cmpType te tr pn = if (compCmpType te tr) == ErrT
                                then ["    param "++ (show pn)++": expected type was '" ++ 
                                     (showCmpType te) ++ "' but recieved type '" ++ 
                                     (showCmpType tr) ++ "'"]
                                else []

controlFnctTipo ps rexps posn = let errs = controlFnctTipo' ps rexps
                                 in if ((length ps) /= (length rexps))
                                     then ["error at "++(showFromPosn posn)++
                                           ": the parameters passed to function are insufficient!"]
                                     else if ((length errs) == 0)
                                            then []
                                            else ["error at "++(showFromPosn posn)++":"]++errs
                      

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

