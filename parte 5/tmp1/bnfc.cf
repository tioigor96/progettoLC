comment "--";

Prog.          Program ::= Block;

-----------
--BLOCCHI--
-----------
Blk.           Block ::= [Statement] ;
BlkDiv.        Block ::= [Statement] DivStm [Statement] ;

--il ; è opzionale, si può mettere uno spazio o un a capo
separator Statement "";
token DivStm ('\n'|';');

rules BasicType ::= "bool" | "char" | "float" | "int" | "string" | "void" ;
rules Boolean ::= "true" | "false";

------------
--STATEMENT-
------------

Stm.           Statement ::= LExp "=" RExp;
StmWhile.      Statement ::= While;
StmRepeat.     Statement ::= Repeat;
StmIf.         Statement ::= If;
Procedure.     Statement ::= Func;
FDecl.         Statement ::= FuncDecl;




-------------
----LEXP-----
-------------

Pointer.  LExp ::= "*" RExp;
IdNew.    LExp ::= NVar;
IdOLD.    LExp ::= OVar;
ArrayEl.  LExp ::= NameVar "[" RExp "]" ;
NewArray. LExp ::= CompoundType NameVar;

NewVariable.  NVar ::= BasicType NameVar;
OldVariable.  OVar ::= NameVar;

token NameVar (letter)(letter|digit|'_')*;
token NameFunc (upper)(letter|digit|'_')*;
------------
--FUNCTIONS && PARAMETERS-
------------
FunctionCall.   Func ::= NameFunc "(" [RExp] ")";
separator RExp ",";

FunctionDeclaration. FuncDecl ::= BasicType NameFunc "(" [Parameters] ")" [FuncStatement] "end";


ParamBasic.      Parameters ::= BasicType NameVar;
ParamCompound.   Parameters ::= CompoundType NameVar;
separator Parameters ",";

NormalStmt.      FuncStatement ::= Statement;
RVar.            FuncStatement ::= "return" RExp;

separator FuncStatement "";


BasTyp.     Type ::= BasicType ;

CompType.   Type ::= CompoundType ;
ArrDef.     CompoundType ::= Type "[" Integer "]" ;
ArrUnDef.   CompoundType ::= Type "["  "]" ;
PType.      CompoundType ::= Type "*" ;

-----------
---CONTROLLO FLUSSO---
-----------

LoopW.         While ::= "while" RExp "do" Block "end";
LoopR.         Repeat ::= "repeat" Block "until" RExp;
LoopIfElse.    If ::= "if" RExp "then" Block [Elseif] Else "end";
LoopIf.        If ::= "if" RExp "then" Block [Elseif]  "end";
ElseV.         Else ::= "else" Block;

ElseifList.    Elseif ::= "elseif" RExp "then" Block;

separator Elseif "";

--------------
--RIGHT EXPRESSIONS-
--------------

token MulDivPer ('*'|'/'|'%');

Or.         RExp ::= RExp "or" RExp1;
And.        RExp ::= RExp1 "and" RExp2;
Not.        RExp2 ::= "not" RExp3;

Eq.         RExp4 ::= RExp4 "==" RExp5;
Neq.        RExp4 ::= RExp4 "!=" RExp5;
Lt.         RExp4 ::= RExp4 "<"  RExp5;
LtE.        RExp4 ::= RExp4 "<=" RExp5;
Gt.         RExp4 ::= RExp4 ">"  RExp5;
GtE.        RExp4 ::= RExp4 ">=" RExp5;

Add.        RExp5 ::= RExp5"+" RExp6;
Sub.        RExp5 ::= RExp5 "-" RExp6;

Mul.        RExp6 ::= RExp6 MulDivPer RExp7;

Pow.        RExp7 ::= RExp8 "^" RExp7 ;

Neg.        RExp8 ::= "-" RExp9 ;
FCall.      RExp9 ::= Func;

ValInt.        RExp10 ::= Integer;
ValVariable.   RExp10 ::= NameVar;
ValDouble.     RExp10 ::= Double;
ValString.     RExp10 ::= String;
ValChar.       RExp10 ::= Char;
ValBoolean.    RExp10 ::= Boolean;

Lexpr.      RExpr11 ::= LExp;

coercions RExp 11;

-------------
----ARRAY----
-------------

separator Element ",";
ElementI.     Element ::= Integer;
ElementD.     Element ::= Double;
ElementS.     Element ::= String;
ElementC.     Element ::= Char;
ElementB.     Element ::= Boolean;
ElementA.     Element ::= Array;
ElementAF.    Element ::= "{" [Element] "}";    


-------------
---VALORI----
-------------

VS.       Value ::= String;
VB.       Value ::= Boolean;
VTab.     Value ::= Array;
VChar.    Value ::= Char;


token Array ('{''}');