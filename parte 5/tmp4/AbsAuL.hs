

module AbsAuL where

-- Haskell module generated by the BNF converter




newtype LIdent = LIdent String deriving (Eq, Ord, Show, Read)
data Program = Prog [PGlobl]
  deriving (Eq, Ord, Show, Read)

data PGlobl = ProgGlobB Stm | ProgGlobF FuncD
  deriving (Eq, Ord, Show, Read)

data Block = Blk [Stm]
  deriving (Eq, Ord, Show, Read)

data BasicType
    = BasicType_Bool
    | BasicType_Char
    | BasicType_Float
    | BasicType_Int
    | BasicType_String
    | BasicType_Void
  deriving (Eq, Ord, Show, Read)

data Boolean = Boolean_true | Boolean_false
  deriving (Eq, Ord, Show, Read)

data PtrVoid = PtrType
  deriving (Eq, Ord, Show, Read)

data CompoundType
    = CompTypeP CompoundType
    | CompTypeM CompoundType
    | CompTypeB BasicType
  deriving (Eq, Ord, Show, Read)

data Stm
    = SDecl Decl
    | SLocal Local
    | SAss Ass
    | SWhile While
    | SRepeat Repeat
    | SFor For
    | SIf If
    | SRExp Func
    | SEBlk EBlk
    | SReturn Return
    | SBreak Break
  deriving (Eq, Ord, Show, Read)

data EBlk = EBlkS Block
  deriving (Eq, Ord, Show, Read)

data Decl = DeclSP BasicType LExp VarInit
  deriving (Eq, Ord, Show, Read)

data VarInit = VarINil | VarExp RExp | VarMat Array
  deriving (Eq, Ord, Show, Read)

data Array = ArrayV0 [Array] | ArrayV1 [VType]
  deriving (Eq, Ord, Show, Read)

data VType
    = VTypeBoolean Boolean
    | VTypeChar Char
    | VTypeDouble Double
    | VTypeInteger Integer
    | VTypeString String
    | VTypePtrVoid PtrVoid
  deriving (Eq, Ord, Show, Read)

data Local = DeclLocal Decl
  deriving (Eq, Ord, Show, Read)

data Ass = AssD LExp RExp
  deriving (Eq, Ord, Show, Read)

data Func
    = FuncBW FuncWrite | FuncBR FuncRead | FnctCall LIdent [RExp]
  deriving (Eq, Ord, Show, Read)

data FuncWrite
    = WriteI RExp | WriteF RExp | WriteC RExp | WriteS RExp
  deriving (Eq, Ord, Show, Read)

data FuncRead = ReadI | ReadF | ReadC | ReadS
  deriving (Eq, Ord, Show, Read)

data While = LoopW RExp EBlk
  deriving (Eq, Ord, Show, Read)

data Repeat = LoopR Block RExp
  deriving (Eq, Ord, Show, Read)

data For
    = LoopF LIdent RExp RExp Increment EBlk | LoopFE LIdent LIdent EBlk
  deriving (Eq, Ord, Show, Read)

data Increment = FIncE | FInc RExp
  deriving (Eq, Ord, Show, Read)

data If = IfM RExp Block [ElseIf] Else
  deriving (Eq, Ord, Show, Read)

data Else = ElseS Block | ElseE
  deriving (Eq, Ord, Show, Read)

data ElseIf = ElseIfD RExp Block
  deriving (Eq, Ord, Show, Read)

data Return = JumpR RValue
  deriving (Eq, Ord, Show, Read)

data RValue = JumpRE | JumpRV RExp
  deriving (Eq, Ord, Show, Read)

data Break = JumpB
  deriving (Eq, Ord, Show, Read)

data FuncD = FnctDecl CompoundType LIdent [ParamF] Block
  deriving (Eq, Ord, Show, Read)

data ParamF = ParmDeclF Modality BasicType LExp
  deriving (Eq, Ord, Show, Read)

data Modality
    = Modality1
    | Modality_val
    | Modality_ref
    | Modality_const
    | Modality_res
    | Modality_valres
    | Modality_name
  deriving (Eq, Ord, Show, Read)

data LExp = LExpS LIdent | LExpDR LExp | LExpA LIdent [Dim]
  deriving (Eq, Ord, Show, Read)

data Dim = Dims Integer
  deriving (Eq, Ord, Show, Read)

data RExp
    = Or RExp RExp
    | And RExp RExp
    | Not RExp
    | Eq RExp RExp
    | Neq RExp RExp
    | Lt RExp RExp
    | LtE RExp RExp
    | Gt RExp RExp
    | GtE RExp RExp
    | Add RExp RExp
    | Sub RExp RExp
    | Mul RExp RExp
    | Div RExp RExp
    | Rem RExp RExp
    | Pow RExp RExp
    | Neg RExp
    | FCall Func
    | FStrCnt RExp RExp
    | FLen RExp
    | ValInt Integer
    | ValVariable LExp
    | ValRef LExp
    | ValDouble Double
    | ValString String
    | ValChar Char
    | ValBoolean Boolean
    | ValPtr PtrVoid
  deriving (Eq, Ord, Show, Read)

