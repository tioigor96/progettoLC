-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParAuL where
import AbsAuL
import LexAuL
import ErrM
import Utils
import Data.Maybe
import Env

}

%name pProgram Program
%name pListPGlobl ListPGlobl
%name pPGlobl PGlobl
%name pBlock Block
%name pListStm ListStm
%name pBasicType BasicType
%name pBoolean Boolean
%name pPtrVoid PtrVoid
%name pCompoundType CompoundType
%name pStm Stm
%name pEBlk EBlk
%name pDecl Decl
%name pVarInit VarInit
%name pArray Array
%name pVType VType
%name pListVType ListVType
%name pListArray ListArray
%name pLocal Local
%name pAss Ass
%name pFunc Func
%name pFuncWrite FuncWrite
%name pFuncRead FuncRead
%name pWhile While
%name pRepeat Repeat
%name pFor For
%name pIncrement Increment
%name pIf If
%name pElse Else
%name pElseIf ElseIf
%name pListElseIf ListElseIf
%name pReturn Return
%name pRValue RValue
%name pBreak Break
%name pListRExp ListRExp
%name pFuncD FuncD
%name pParamF ParamF
%name pListParamF ListParamF
%name pModality Modality
%name pLExp LExp
%name pListDim ListDim
%name pDim Dim
%name pRExp RExp
%name pRExp2 RExp2
%name pRExp3 RExp3
%name pRExp6 RExp6
%name pRExp7 RExp7
%name pRExp8 RExp8
%name pRExp9 RExp9
%name pRExp10 RExp10
%name pRExp11 RExp11
%name pRExp1 RExp1
%name pRExp4 RExp4
%name pRExp5 RExp5
%name pRExp12 RExp12
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '..' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '<=' { PT _ (TS _ 14) }
  '=' { PT _ (TS _ 15) }
  '==' { PT _ (TS _ 16) }
  '>' { PT _ (TS _ 17) }
  '>=' { PT _ (TS _ 18) }
  'Bool' { PT _ (TS _ 19) }
  'Char' { PT _ (TS _ 20) }
  'Float' { PT _ (TS _ 21) }
  'Int' { PT _ (TS _ 22) }
  'String' { PT _ (TS _ 23) }
  'Void' { PT _ (TS _ 24) }
  '[' { PT _ (TS _ 25) }
  ']' { PT _ (TS _ 26) }
  '^' { PT _ (TS _ 27) }
  'and' { PT _ (TS _ 28) }
  'break' { PT _ (TS _ 29) }
  'const' { PT _ (TS _ 30) }
  'do' { PT _ (TS _ 31) }
  'else' { PT _ (TS _ 32) }
  'elseif' { PT _ (TS _ 33) }
  'end' { PT _ (TS _ 34) }
  'false' { PT _ (TS _ 35) }
  'for' { PT _ (TS _ 36) }
  'function' { PT _ (TS _ 37) }
  'if' { PT _ (TS _ 38) }
  'in' { PT _ (TS _ 39) }
  'local' { PT _ (TS _ 40) }
  'name' { PT _ (TS _ 41) }
  'nil' { PT _ (TS _ 42) }
  'not' { PT _ (TS _ 43) }
  'or' { PT _ (TS _ 44) }
  'readChar' { PT _ (TS _ 45) }
  'readFloat' { PT _ (TS _ 46) }
  'readInt' { PT _ (TS _ 47) }
  'readString' { PT _ (TS _ 48) }
  'ref' { PT _ (TS _ 49) }
  'repeat' { PT _ (TS _ 50) }
  'res' { PT _ (TS _ 51) }
  'return' { PT _ (TS _ 52) }
  'then' { PT _ (TS _ 53) }
  'true' { PT _ (TS _ 54) }
  'until' { PT _ (TS _ 55) }
  'val' { PT _ (TS _ 56) }
  'valres' { PT _ (TS _ 57) }
  'while' { PT _ (TS _ 58) }
  'writeChar' { PT _ (TS _ 59) }
  'writeFloat' { PT _ (TS _ 60) }
  'writeInt' { PT _ (TS _ 61) }
  'writeString' { PT _ (TS _ 62) }
  '{' { PT _ (TS _ 63) }
  '}' { PT _ (TS _ 64) }
  '~=' { PT _ (TS _ 65) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_LIdent { PT _ (T_LIdent _) }

-- tipi per gli attributi di $$
%attributetype { AttrTree a }
%attribute res { Result }
%attribute parsetree { a }
%attribute vint { Integer }
%attribute vdbl { Double }
%attribute vchr { Char }
%attribute vstr { String }
%attribute vlident { LIdent }

-- attributi per il frontend
%attribute envin { EnvT }       -- env più esterno
%attribute envloc { EnvT }      -- env del blocco locale
%attribute envout { EnvT }      -- env del blocco uscente
%attribute errs { [String] }
%attribute posn { Posn }
%attribute tipo { BasicType }
-- %attribute jmpi { TAC }      -- conviene gestirlo da TAC, in quanto il jmp è 
                                -- all'etichetta fuori del ciclo
-- %attribute jmpo { TAC }      -- come sopra



%%

Integer : L_integ  { $$.vint = (read ( $1)) :: Integer }
Double : L_doubl  {  $$.vdbl = (read ( $1)) :: Double }
String : L_quoted { $$.vstr = $1 }
Char : L_charac {  $$.vchr = (read ( $1)) :: Char }
LIdent : L_LIdent 
    {         
            $$.posn =  (tokenPosn $1)                           
            ; $$.vlident = LIdent (getLIdentT $1)
    }

Program : ListPGlobl
    { 
        $1.envin = emptyEnv
        ; $1.envloc = emptyEnv
        ; $$.res = Result (AbsAuL.Prog $1.parsetree ) "qui TAC" $1.envout $1.errs
    }

ListPGlobl : PGlobl 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = (:[]) $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    } 
    | PGlobl ListPGlobl
    { 
        $1.envin = $$.envin
        ; $2.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $2.envloc = $1.envout
        ; $$.parsetree = (:) $1.parsetree $2.parsetree
        ; $$.envout = $2.envout
        ; $$.errs = $1.errs ++ $2.errs
        
    }

PGlobl : Stm 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.ProgGlobB $1.parsetree
        ; $$.envout = $1.envout 
        ; $$.errs = $1.errs
    }
       | FuncD 
    { 
        $$.parsetree = AbsAuL.ProgGlobF $1.parsetree
        ; $1.envin = $$.envin 
        ; $$.envout = $1.envout 
        ; $$.errs = $1.errs
    }

--  ========================
--  =======  BLKS  =========
--  ========================

Block : ListStm 
    { 
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $1.envloc = emptyEnv
        ; $$.parsetree = AbsAuL.Blk $1.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = $1.errs
        
    }
ListStm : {- empty -} 
    { 
        $$.parsetree = [] 
        ; $$.envout = $$.envloc
        ; $$.errs = []
    } 
    | ListStm Stm
    { 
        $1.envin = $$.envin
        ; $2.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $2.envloc = $1.envout
        ; $$.parsetree =  flip (:) $1.parsetree $2.parsetree
        ; $$.envout = $2.envout
        ; $$.errs = $1.errs ++ $2.errs
    }

--  ========================
--  ======= TIPI   =========
--  ========================

BasicType : 'Bool' 
    { 
        $$.parsetree = AbsAuL.BasicType_Bool 
    }
    | 'Char' 
    { 
        $$.parsetree = AbsAuL.BasicType_Char 
    }
    | 'Float' 
    { 
        $$.parsetree = AbsAuL.BasicType_Float 
    }
    | 'Int' 
    { 
        $$.parsetree = AbsAuL.BasicType_Int 
    }
    | 'String' 
    { 
        $$.parsetree = AbsAuL.BasicType_String 
    }
    | 'Void' 
    { 
        $$.parsetree = AbsAuL.BasicType_Void 
    }

Boolean : 'true' { $$.parsetree = AbsAuL.Boolean_true }
        | 'false' { $$.parsetree = AbsAuL.Boolean_false }

PtrVoid : 'nil' { $$.parsetree = AbsAuL.PtrType }

CompoundType : '*' CompoundType { $$.parsetree = AbsAuL.CompTypeP $2.parsetree }
             | CompoundType '[' ']' { $$.parsetree = AbsAuL.CompTypeM $1.parsetree }
             | BasicType { $$.parsetree = AbsAuL.CompTypeB $1.parsetree }

--  ========================
--  =======  STM   =========
--  ========================

Stm : Decl ';' 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SDecl $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | Local ';' 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SLocal $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | Ass ';' 
    { 
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $$.parsetree = AbsAuL.SAss $1.parsetree 
        ; $$.envout = $$.envloc
        ; $$.errs = $1.errs
    }
    | While 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SWhile $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | Repeat ';' 
    {
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc 
        ; $$.parsetree = AbsAuL.SRepeat $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs 
    }
    | For 
    {
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SFor $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
    }
    | If 
    { 
        $$.parsetree = AbsAuL.SIf $1.parsetree 
    }
    | Func ';' 
    { 
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $$.parsetree = AbsAuL.SRExp $1.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = $1.errs
    }
    | EBlk 
    {
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SEBlk $1.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = $1.errs
    }
    | Return ';' 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsAuL.SReturn $1.parsetree
    }
    | Break ';' 
    { 
        $$.parsetree = AbsAuL.SBreak $1.parsetree
    }

--  ========================
--  =======  EBLK  =========
--  ========================

EBlk : 'do' Block 'end' 
    { 
        $2.envin = $$.envin
        ; $2.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.EBlkS $2.parsetree
        ; $$.errs = $2.errs
    }

--  ========================
--  =======  DECL  =========
--  ========================
-- passa a VarInit env e variem implementa controllo tipo
Decl : BasicType LExp VarInit 
    { 
        $3.envin = (mergeEnv $$.envloc $$.envin)
        ; $$.parsetree = AbsAuL.DeclSP $1.parsetree $2.parsetree $3.parsetree
        ; $$.envout = ( if (isOk (insertEnv $1.parsetree Modality1 $2.parsetree $$.envloc $2.posn))
                         then (fromOk (insertEnv $1.parsetree Modality1 $2.parsetree $$.envloc $2.posn))
                         else $3.envloc
                        )
        ; $$.errs = ( if (isJust (lookupEnv ( (fromLIdent . getLIdentlexp) $2.parsetree) $$.envloc))
                         then ["error at "++ (showFromPosn $2.posn) ++": variable " ++ 
                                (fromBad (insertEnv $1.parsetree Modality1 $2.parsetree $$.envloc $2.posn))]
                         else if(not($3.tipo == BasicType_Void) && not($1.parsetree == $3.tipo))
                            then ["error at "++ (showFromPosn $2.posn) ++": variable was defined as '"++ 
                                  (showBBType $1.parsetree) ++ "' but initialization has type of '"++(showBBType $3.tipo)++"'"]
                            else []
                        ) ++ $3.errs
                            
    }

VarInit : {- empty -} 
    { 
        
        $$.parsetree = AbsAuL.VarINil
        ; $$.errs = []
        ; $$.tipo = BasicType_Void
    }
    | '=' RExp 
    {
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.VarExp $2.parsetree 
        ; $$.errs = []
        ; $$.tipo = $2.tipo
    }
    | '=' Array 
    { 
        $$.parsetree = AbsAuL.VarMat $2.parsetree 
    }


Array : '{' ListArray '}'
    { 
        $$.parsetree = AbsAuL.ArrayV0 $2.parsetree 
    }
    | '{' ListVType '}' 
    { 
        $$.parsetree = AbsAuL.ArrayV1 $2.parsetree 
    }
VType : Boolean 
    { 
        $$.parsetree = AbsAuL.VTypeBoolean $1.parsetree 
    }
    | Char --modded
    { 
        $$.parsetree = AbsAuL.VTypeChar $1.vchr 
    }
    | Double --modded
    { 
        $$.parsetree = AbsAuL.VTypeDouble $1.vdbl 
    }
    | Integer --modded
    { 
        $$.parsetree = AbsAuL.VTypeInteger $1.vint
    }
    | String --modded
    { 
        $$.parsetree = AbsAuL.VTypeString $1.vstr 
    }
    | PtrVoid 
    { 
        $$.parsetree = AbsAuL.VTypePtrVoid $1.parsetree 
    }
ListVType : VType 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    } 
    | VType ',' ListVType 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree 
    }
ListArray : Array 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    } 
    | Array ',' ListArray 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree
    }

--  ========================
--  =======  LOCL  =========
--  ========================

Local : 'local' Decl 
    { 
        $2.envin = (mergeEnv $$.envloc $$.envin)
        ; $2.envloc = emptyEnv
        ; $$.parsetree = AbsAuL.DeclLocal $2.parsetree 
        ; $$.envout = (mergeEnv $2.envout $$.envloc)
        ; $$.errs = $2.errs
    }

--  ========================
--  =======  ASSG  =========
--  ========================

Ass : LExp '=' RExp 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.AssD $1.parsetree $3.parsetree
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                        then (if ((isVarEnv . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                then ((fst . getTypeV . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                else BasicType_Void )
                        else BasicType_Void )
        ; $$.errs = (if ($$.tipo == BasicType_Void)
                         then []
                         else if ($$.tipo == $3.tipo)
                                  then if((snd . getTypeV . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin) == Modality_const)
                                         then ["error at " ++ ((showFromPosn . tokenPosn) $2) ++
                                               ": cannot assign value to a constant variable "++
                                               ((fromLIdent . getLIdentlexp) $1.parsetree) ++"!"]
                                         else []
                                  else ["error at " ++ ((showFromPosn . tokenPosn) $2) ++ ": expects argument of type '" ++ (showBBType $$.tipo) ++ "' but has type '"++ (showBBType $3.tipo) ++"'"]) ++ $3.errs
    }

--  ========================
--  =======  FUNC  =========
--  ========================

Func : FuncWrite 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsAuL.FuncBW $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = AbsAuL.BasicType_Void
    }
    | FuncRead 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsAuL.FuncBR $1.parsetree 
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }
    | LIdent '(' ListRExp ')' --modded
    { 
        $$.parsetree = AbsAuL.FnctCall $1.vlident $3.parsetree 
    }
ListRExp : {- empty -} 
    { 
        $$.parsetree = [] 
    }
    | RExp 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    }
    | RExp ',' ListRExp 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree 
    }

FuncWrite : 'writeInt' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.WriteI $3.parsetree
        ; $$.errs = (if (not($3.tipo == BasicType_Int))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeInt' need to be Int!"]
                        else []
                     ) ++ $3.errs
    }
    | 'writeFloat' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.WriteF $3.parsetree
        ; $$.errs = (if (not ($3.tipo == BasicType_Float))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeFloat' need to be Float!"]
                        else []
                     ) ++ $3.errs
    }
    | 'writeChar' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.WriteC $3.parsetree
        ; $$.errs = (if (not ($3.tipo == BasicType_Char))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeChar' need to be Char!"]
                        else []
                     ) ++ $3.errs
    }
    | 'writeString' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.WriteS $3.parsetree
        ; $$.errs = (if (not ($3.tipo == BasicType_String))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeString' need to be String!"]
                        else []
                     ) ++ $3.errs
    }

FuncRead : 'readInt' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadI
        ; $$.tipo = BasicType_Int
        ; $$.errs = []
    }
    | 'readFloat' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadF
        ; $$.tipo = BasicType_Float
        ; $$.errs = []
    }
    | 'readChar' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadC
        ; $$.tipo = BasicType_Char
        ; $$.errs = []
    }
    | 'readString' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadS
        ; $$.tipo = BasicType_String
        ; $$.errs = []
    }

--  ========================
--  =======  WHLE  =========
--  ========================

While : 'while' RExp EBlk 
    { 
        $2.envin = mergeEnv $$.envloc $$.envin
        ; $3.envin = $$.envin
        ; $3.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.LoopW $2.parsetree $3.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = $2.errs ++ $3.errs
    }

--  ========================
--  =======  REPT  =========
--  ========================

Repeat : 'repeat' Block 'until' RExp 
    { 
        $2.envin = $$.envin
        ; $2.envloc = $$.envloc
        ; $4.envin = mergeEnv $$.envloc $$.envin
        ; $$.parsetree = AbsAuL.LoopR $2.parsetree $4.parsetree
        ; $$.envout = $2.envout
        ; $$.errs = $2.errs ++ $4.errs
    }

--  ========================
--  =======  FORS  =========
--  ========================

For : 'for' LIdent '=' RExp ',' RExp Increment EBlk --modded
    { 
        $4.envin = mergeEnv $$.envloc $$.envin
        ; $6.envin = mergeEnv $$.envloc $$.envin
        ; $7.envin = mergeEnv $$.envloc $$.envin
        
        ; $8.envin = mergeEnv $$.envloc $$.envin
        ; $8.envloc = if((all (\(x,y) -> x == y ) [($4.tipo,$6.tipo),($6.tipo,$7.tipo),($7.tipo,$4.tipo)]) )
                        then (fromOk (insertEnv $7.tipo Modality1 (LExpS $2.vlident) emptyEnv $2.posn))
                        else (fromOk (insertEnv BasicType_Int Modality1 (LExpS $2.vlident) emptyEnv $2.posn))
        
        ; $$.parsetree = AbsAuL.LoopF $2.vlident $4.parsetree $6.parsetree $7.parsetree $8.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = (if ( all (\(x,y) -> x == y ) [($4.tipo,$6.tipo),($6.tipo,$7.tipo),($7.tipo,$4.tipo)])
                        then []
                        else ["error at "++ (showFromPosn $2.posn) ++": incompatible types in 'for' loop conditions!"])
                               ++ $4.errs ++ $6.errs ++ $7.errs ++ $8.errs
    }
    | 'for' LIdent 'in' LIdent EBlk --modded
    { 
        $$.parsetree = AbsAuL.LoopFE $2.vlident $4.vlident $5.parsetree 
    }
Increment : {- empty -} -- per l'appunto, assumiamo sia 1 l'incremento
    { 
        $$.parsetree = AbsAuL.FIncE
        ; $$.tipo = BasicType_Int
        ; $$.errs = []
    }
    | ',' RExp 
    { 
        $$.parsetree = AbsAuL.FInc $2.parsetree
        ; $$.tipo = $2.tipo
        ; $$.errs = $2.errs
    }
    
--  ========================
--  =======   IF   =========
--  ========================
If : 'if' RExp 'then' Block ListElseIf Else 'end' --occhio al $5
    { 
        $$.parsetree = AbsAuL.IfM $2.parsetree $4.parsetree (reverse $5.parsetree) $6.parsetree    
    }

Else : 'else' Block 
    { 
        $$.parsetree = AbsAuL.ElseS $2.parsetree 
    }
    | {- empty -} 
    { 
        $$.parsetree = AbsAuL.ElseE 
    }

ElseIf : 'elseif' RExp 'then' Block 
    { 
        $$.parsetree = AbsAuL.ElseIfD $2.parsetree $4.parsetree 
    }

ListElseIf : {- empty -} 
    { 
        $$.parsetree = [] 
    }
    | ListElseIf ElseIf 
    { 
        $$.parsetree = flip (:) $1.parsetree $2.parsetree 
    }

--  ========================
--  =======  JUMP  =========
--  ========================

Return : 'return' RValue 
    { 
        $$.parsetree = AbsAuL.JumpR $2.parsetree 
    }

RValue : {- empty -} 
    { 
        $$.parsetree = AbsAuL.JumpRE 
    }
    | RExp 
    { 
        $$.parsetree = AbsAuL.JumpRV $1.parsetree 
    }

Break : 'break' 
    { 
        $$.parsetree = AbsAuL.JumpB 
    }

--  ========================
--  =======  FUND  =========
--  ========================

FuncD : CompoundType 'function' LIdent '(' ListParamF ')' Block 'end' --modded
    { 
        $$.parsetree = AbsAuL.FnctDecl $1.parsetree $3.vlident $5.parsetree $7.parsetree 
    }
ParamF : Modality BasicType LExp 
    { 
        $$.parsetree = AbsAuL.ParmDeclF $1.parsetree $2.parsetree $3.parsetree 
    }
ListParamF : {- empty -} 
    { 
        $$.parsetree = [] 
    }
    | ParamF 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    }
    | ParamF ',' ListParamF 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree 
    }
Modality : {- empty -} 
    { 
        $$.parsetree = AbsAuL.Modality1 
    }
    | 'val' 
    { 
        $$.parsetree = AbsAuL.Modality_val
    }
    | 'ref' 
    { 
        $$.parsetree = AbsAuL.Modality_ref 
    }
    | 'const' 
    { 
        $$.parsetree = AbsAuL.Modality_const 
    }
    | 'res' 
    { 
        $$.parsetree = AbsAuL.Modality_res 
    }
    | 'valres' 
    { 
        $$.parsetree = AbsAuL.Modality_valres 
    }
    | 'name' 
    { 
        $$.parsetree = AbsAuL.Modality_name 
    }
--  ========================
--  =======  LEXP  =========
--  ========================
LExp : LIdent --modded
    { 
        $$.parsetree = AbsAuL.LExpS $1.vlident
        ; $$.posn = $1.posn
    }
    | '*' LExp 
    { 
        $$.parsetree = AbsAuL.LExpDR $2.parsetree 
        ; $$.posn = $2.posn
    }
    | LIdent ListDim --modded
    { 
        $$.parsetree = AbsAuL.LExpA $1.vlident $2.parsetree
        ; $$.posn = $1.posn
    }

ListDim : Dim 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    } 
    | Dim ListDim 
    { 
        $$.parsetree = (:) $1.parsetree $2.parsetree 
    }

Dim : '[' Integer ']' --modded
    { 
        $$.parsetree = AbsAuL.Dims $2.vint 
    }

--  ========================
--  =======  REXP  =========
--  ========================

RExp : RExp 'or' RExp1 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Or $1.parsetree $3.parsetree
        ; $$.errs = (if (($1.tipo == BasicType_Bool) && ($3.tipo == BasicType_Bool))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for 'or' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = BasicType_Bool 
    }
    | RExp1 'and' RExp2 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.And $1.parsetree $3.parsetree
        ; $$.errs = (if (($1.tipo == BasicType_Bool) && ($3.tipo == BasicType_Bool))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for 'and' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = BasicType_Bool
    }
    | RExp1 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp2 : 'not' RExp3 
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.Not $2.parsetree
        ; $$.errs = (if ($2.tipo == BasicType_Bool)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $1) ++ ": type need to be compatible for 'and' operations!"]) ++ $2.errs
        ; $$.tipo = BasicType_Bool
    } 
    | RExp3 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp3 : RExp3 '==' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Eq $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '==' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = BasicType_Bool 
    }
    | RExp3 '~=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Neq $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '~=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = BasicType_Bool 
    }
    | RExp3 '<' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Lt $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '<' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = BasicType_Bool
    }
    | RExp3 '<=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.LtE $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '<=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = BasicType_Bool
    }
    | RExp3 '>' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Gt $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '>' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = BasicType_Bool
    }
    | RExp3 '>=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.GtE $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '>=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = BasicType_Bool
    }
    | RExp4 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp6 : RExp6 '+' RExp7 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Add $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = (if (($1.tipo == BasicType_Float) || ($3.tipo == BasicType_Float))
                         then BasicType_Float
                         else BasicType_Int )  
    }
    | RExp6 '-' RExp7 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Sub $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = (if (($1.tipo == BasicType_Float) || ($3.tipo == BasicType_Float))
                         then BasicType_Float
                         else BasicType_Int )  
    }
    | RExp7 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp7 : RExp7 '*' RExp8 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Mul $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = (if (($1.tipo == BasicType_Float) || ($3.tipo == BasicType_Float))
                         then BasicType_Float
                         else BasicType_Int ) 
    }
    | RExp7 '/' RExp8 
    {
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Div $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = (if (($1.tipo == BasicType_Float) || ($3.tipo == BasicType_Float))
                         then BasicType_Float
                         else BasicType_Int )
    }
    | RExp7 '%' RExp8 
    {   
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Rem $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = BasicType_Int
    }
    | RExp8 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp8 : RExp9 '^' RExp8 
    {   
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Pow $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then $1.tipo
                         else BasicType_Float )
    } 
    | RExp9 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }
RExp9 : '-' RExp10 -- tipo numerico!! per il momento lasciamo sia int o float
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.Neg $2.parsetree
        ; $$.errs = ( if (($2.tipo == BasicType_Int) || ($2.tipo == BasicType_Float))
                         then []
                         else ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type need to be Int or Float!"]   ) ++ $2.errs
        ; $$.tipo = ( if (($2.tipo == BasicType_Int) || ($2.tipo == BasicType_Float))
                         then $2.tipo
                         else BasicType_Float )
    } 
    | RExp10 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp10 : Func --TODO: sistema la roba dentro func
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsAuL.FCall $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }
    | RExp10 '..' RExp11 -- temporaneamente ignorato
    { 
        $$.parsetree = AbsAuL.FStrCnt $1.parsetree $3.parsetree 
    }
    | '#' RExp11 -- temporaneamente ignorato
    { 
        $$.parsetree = AbsAuL.FLen $2.parsetree 
    }
    | RExp11 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }
RExp11 : Integer --modded
    { 
        $$.parsetree = AbsAuL.ValInt $1.vint
        ; $$.tipo = BasicType_Int
        ; $$.envout = $$.envin
        ; $$.errs = []
    }
    | LExp 
    { 
        $$.parsetree = AbsAuL.ValVariable $1.parsetree 
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                        then (if ((isVarEnv . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                then ((fst . getTypeV . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                else BasicType_Void )
                        else BasicType_Void ) 
        ; $$.errs = (if ($$.tipo == BasicType_Void)
                        then ["error: reference to " ++ ((fromLIdent . getLIdentlexp) $1.parsetree) ++ " at line " ++
                                (showFromPosn $1.posn) ++ "is invalid (maybe a function or not declared variable?)"]
                        else [])
    }
    | '&' LExp 
    { 
        $$.parsetree = AbsAuL.ValRef $2.parsetree
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                        then (if ((isVarEnv . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                                then ((fst . getTypeV . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                                else BasicType_Void )
                        else BasicType_Void )
        ; $$.errs = (if ($$.tipo == BasicType_Void)
                        then ["error: reference to " ++ ((fromLIdent . getLIdentlexp) $2.parsetree) ++ " at line " ++
                                (showFromPosn $2.posn) ++ "is invalid (maybe a function or not declared variable?)"]
                        else [])
    }
    | Double --modded
    { 
        $$.parsetree = AbsAuL.ValDouble $1.vdbl
        ; $$.tipo = BasicType_Float
        ; $$.errs = []
    }
    | String --modded
    { 
        $$.parsetree = AbsAuL.ValString $1.vstr
        ; $$.tipo = BasicType_String
        ; $$.errs = []
    }
    | Char --modded
    { 
        $$.parsetree = AbsAuL.ValChar $1.vchr
        ; $$.tipo = BasicType_Char
        ; $$.errs = []
    }
    | Boolean 
    { 
        $$.parsetree = AbsAuL.ValBoolean $1.parsetree
        ; $$.tipo = BasicType_Int
        ; $$.errs = []
    }
    | PtrVoid 
    { 
        $$.parsetree = AbsAuL.ValPtr $1.parsetree
        ; $$.tipo = BasicType_Void
        ; $$.errs = []
    }
    | RExp12 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree 
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }
RExp1 : RExp2 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }
RExp4 : RExp5 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp5 : RExp6 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
    }
RExp12 : '(' RExp ')' 
    { 
        $2.envin = $$.envin
        ; $$.parsetree = $2.parsetree
        ; $$.errs = $2.errs
        ; $$.tipo = $2.tipo 
    }

{

data Result = Result Program String EnvT [String]  deriving (Eq, Show)

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

