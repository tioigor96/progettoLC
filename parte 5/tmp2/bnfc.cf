comment "--";

Prog.          Program ::= [PGlobl] {-Program-} ;
--ProgE.         Program ::= {- empty -};

separator PGlobl "";

ProgGlobB.     PGlobl ::= Stm StmDiv ;
ProgGlobF.     PGlobl ::= FuncD ;


-----------
--BLOCCHI--
-----------

Blk.           Block ::= Stm StmDiv ;
Blks.          Block ::= Stm StmDiv Block ;

--TODO: SISTEMA STO CAZZO DI TOKEN
token StmDiv ('\n' | ';');


------------
--GESTIONE TIPI--
-------------

BasTyp.     Type ::= BasicType ;

rules          BasicType ::= "Bool" | "Char" | "Float" | "Int" | "String" | "Void" ;
rules          Boolean   ::= "true" | "false";
PtrType.       PtrVoid   ::= "nil";


------------
--STATEMENT-
------------

SDecl.      Stm ::= Decl;
SLocal.     Stm ::= Local;
SAss.       Stm ::= Ass;
SWhile.     Stm ::= While;
SRepeat.    Stm ::= Repeat;
SFor.       Stm ::= For;
SIf.        Stm ::= If;
SRExp.      Stm ::= RExp;
SEBlk.      Stm ::= EBlk;
SReturn.    Stm ::= Return;
SBreak.     Stm ::= Break;


-------------
----BLCK-----
-------------
EBlk.       EBlk ::= "do" Block "end" ;

-------------
----DECL-----
-------------

DeclSP.      Decl ::= Type LExp VarInit ;
VarINil.     VarInit ::= {- empty -} ;
VarExp.      VarInit ::= "=" RExp ;

DeclLocal.   Local ::= "local" Decl;

token LIdent (letter|'_'lower)(letter|digit|'_')*;


-------------
----ASGN-----
-------------
AssD.        Ass ::= LExp "=" RExp;

------------
--Base Fnct-
------------
FuncBW.      Func ::= FuncWrite ;
FuncBR.      Func ::= FuncRead ;


-- TODO: #::(strlen) e ..::(strconcat) 

WriteI.    FuncWrite ::= "writeInt" "(" Integer ")";
WriteF.    FuncWrite ::= "writeFloat" "(" Double ")";
WriteC.    FuncWrite ::= "writeChar" "(" Char ")";
WriteS.    FuncWrite ::= "writeString" "(" String ")";

ReadI.     FuncRead ::= "readInt" "(" Integer ")";
ReadF.     FuncRead ::= "readFloat" "(" Double ")";
ReadC.     FuncRead ::= "readChar" "(" Char ")";
ReadS.     FuncRead ::= "readString" "(" String ")";

-----------
---LOOPS---
-----------
LoopW.         While ::= "while" RExp "do" Block "end";
LoopR.         Repeat ::= "repeat" RExp "until" RExp;
LoopF.         For ::= "for" LIdent "=" RExp "," [RExp] "do" Block "end";
LoopFE.        For ::= "for" LIdent "in" LIdent "do" Block "end";

separator nonempty RExp ",";

------------
---IFELSE---
------------
IfM.        If     ::= "if" RExp "then" Block [ElseIf] Else "end" ;
IfE.        If     ::= "if" RExp "then" Block Else "end";
IfS.        If     ::= "if" RExp "then" Block "end";
ElseS.      Else ::= "else" Block;

ElseIfD.    ElseIf ::= "elseif" RExp "then" Block ;
separator nonempty ElseIf "";



------------
----JUMPS---
------------
JumpR.      Return ::= "return" RValue ;
JumpRE.     RValue ::= {- empty -};
JumpRV.     RValue ::= RExp;

-- break accettabile solo dentro loops!! (da gestire similmente a side effect?)
JumpB.      Break ::= "break";

------------
--FUNCTIONS && PARAMETERS-
------------

rules Modality ::= {-empty-} | "val" | "ref";
-- da gestire in futuro EVENTUALMENTE
-- | "const" | "res" | "valres" | "name" ;

FnctCall.   Func ::= LIdent "(" [Param] ")";
FnctCallPE. Param ::= RExp ;
FnctCallPP. Param ::= "&" RExp ;

separator Param ",";




ParmDeclF.   ParamF ::= Modality Type LExp;      

FnctDecl.   FuncD ::= BasicType "function" LIdent "(" [ParamF] ")" Block "end";
separator ParamF "," ;


-------------
----LEXP-----
-------------

LExpS.  LExp ::= LIdent;
LExpP.  LExp ::= "*" LExp ;

-- LExp array
LExpA.  LExp ::= LIdent [Dim] ;
separator nonempty Dim "";

Dims.   Dim ::= "[" Integer "]" ;


--------------
-----REXP-----
--------------

Or.            RExp ::= RExp "or" RExp1;
And.           RExp ::= RExp1 "and" RExp2;
Not.           RExp2 ::= "not" RExp3;

Eq.            RExp3 ::= RExp3 "==" RExp5;
Neq.           RExp3 ::= RExp3 "~=" RExp5;
Lt.            RExp3 ::= RExp3 "<"  RExp5;
LtE.           RExp3 ::= RExp3 "<=" RExp5;
Gt.            RExp3 ::= RExp3 ">"  RExp5;
GtE.           RExp3 ::= RExp3 ">=" RExp5;

Add.           RExp6 ::= RExp6 "+" RExp7;
Sub.           RExp6 ::= RExp6 "-" RExp7;

Mul.           RExp7 ::= RExp7 "*" RExp8;
Div.           RExp7 ::= RExp7 "/" RExp8;
Rem.           RExp7 ::= RExp7 "%" RExp8;


Pow.           RExp8 ::= RExp9 "^" RExp8 ;

Neg.           RExp9 ::= "-" RExp10 ;
FCall.         RExp10 ::= Func ;
FStrCnt.       RExp10 ::= RExp10 ".." RExp11 ;
FLen.          RExp10 ::= "#" RExp11 ;

ValInt.        RExp11 ::= Integer;
ValVariable.   RExp11 ::= LExp;
ValDouble.     RExp11 ::= Double;
ValString.     RExp11 ::= String;
ValChar.       RExp11 ::= Char;
ValBoolean.    RExp11 ::= Boolean;
ValPtr.        RExp11 ::= PtrVoid;

-- Array definition "inline"
VarMArr.       RExp12 ::= "{" MyArrayD "}";

MyArrayLType.  MyArrayD ::= "{" MyArrayD "}";
MyArrayLType1. MyArrayD ::= RExp12 "," "{" MyArrayD "}" ;
MyArrayType.   MyArrayD ::= MyArray ;
MyArrayB.      MyArray  ::= [ArrB] ;
MyArrayC.      MyArray  ::= [ArrC] ;
MyArrayF.      MyArray  ::= [ArrF] ;
MyArrayI.      MyArray  ::= [ArrI] ;
MyArrayS.      MyArray  ::= [ArrS] ;
MyArrayE.      MyArray  ::= [ArrE] ;
MyArrayP.      MyArray  ::= [ArrP] ;

separator nonempty ArrB ",";
separator nonempty ArrC ",";
separator nonempty ArrF ",";
separator nonempty ArrI ",";
separator nonempty ArrS ",";
separator nonempty ArrE ",";
separator nonempty ArrP ",";

ArrVB.         ArrB ::= Boolean;
ArrVC.         ArrC ::= Char;
ArrVF.         ArrF ::= Double;
ArrVI.         ArrI ::= Integer;
ArrVS.         ArrS ::= String;
ArrVP.         ArrP ::= PtrVoid;
ArrVE.         ArrE ::= {- empty -};

coercions RExp 13;




