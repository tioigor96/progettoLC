-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParAuL where
import AbsAuL
import LexAuL
import ErrM
import Utils
import Data.Maybe
import Env
import Code
import TAC

}

%name pProgram Program
%name pListPGlobl ListPGlobl
%name pPGlobl PGlobl
%name pBlock Block
%name pBlock BlockF
%name pListStm ListStm
%name pBasicType BasicType
%name pBoolean Boolean
%name pPtrVoid PtrVoid
%name pCompoundType CompoundType
%name pStm Stm
%name pEBlk EBlk
%name pDecl Decl
%name pVarInit VarInit
%name pArray Array
%name pVType VType
%name pListVType ListVType
%name pListArray ListArray
%name pLocal Local
%name pAss Ass
%name pFunc Func
%name pFuncWrite FuncWrite
%name pFuncRead FuncRead
%name pWhile While
%name pRepeat Repeat
%name pFor For
%name pIncrement Increment
%name pIf If
%name pElse Else
%name pElseIf ElseIf
%name pListElseIf ListElseIf
%name pReturn Return
%name pRValue RValue
%name pBreak Break
%name pListRExp ListRExp
%name pFuncD FuncD
%name pParamF ParamF
%name pListParamF ListParamF
%name pModality Modality
%name pLExp LExp
%name pListDim ListDim
%name pDim Dim
%name pRExp RExp
%name pRExp2 RExp2
%name pRExp3 RExp3
%name pRExp6 RExp6
%name pRExp7 RExp7
%name pRExp8 RExp8
%name pRExp9 RExp9
%name pRExp10 RExp10
%name pRExp11 RExp11
%name pRExp1 RExp1
%name pRExp4 RExp4
%name pRExp5 RExp5
%name pRExp12 RExp12
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '..' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '<=' { PT _ (TS _ 14) }
  '=' { PT _ (TS _ 15) }
  '==' { PT _ (TS _ 16) }
  '>' { PT _ (TS _ 17) }
  '>=' { PT _ (TS _ 18) }
  'Bool' { PT _ (TS _ 19) }
  'Char' { PT _ (TS _ 20) }
  'Float' { PT _ (TS _ 21) }
  'Int' { PT _ (TS _ 22) }
  'String' { PT _ (TS _ 23) }
  'Void' { PT _ (TS _ 24) }
  '[' { PT _ (TS _ 25) }
  ']' { PT _ (TS _ 26) }
  '^' { PT _ (TS _ 27) }
  'and' { PT _ (TS _ 28) }
  'break' { PT _ (TS _ 29) }
  'const' { PT _ (TS _ 30) }
  'do' { PT _ (TS _ 31) }
  'else' { PT _ (TS _ 32) }
  'elseif' { PT _ (TS _ 33) }
  'end' { PT _ (TS _ 34) }
  'false' { PT _ (TS _ 35) }
  'for' { PT _ (TS _ 36) }
  'function' { PT _ (TS _ 37) }
  'if' { PT _ (TS _ 38) }
  'local' { PT _ (TS _ 39) }
  'name' { PT _ (TS _ 40) }
  'nil' { PT _ (TS _ 41) }
  'not' { PT _ (TS _ 42) }
  'or' { PT _ (TS _ 43) }
  'readChar' { PT _ (TS _ 44) }
  'readFloat' { PT _ (TS _ 45) }
  'readInt' { PT _ (TS _ 46) }
  'readString' { PT _ (TS _ 47) }
  'repeat' { PT _ (TS _ 48) }
  'res' { PT _ (TS _ 49) }
  'return' { PT _ (TS _ 50) }
  'then' { PT _ (TS _ 51) }
  'true' { PT _ (TS _ 52) }
  'until' { PT _ (TS _ 53) }
  'val' { PT _ (TS _ 54) }
  'valres' { PT _ (TS _ 55) }
  'while' { PT _ (TS _ 56) }
  'writeChar' { PT _ (TS _ 57) }
  'writeFloat' { PT _ (TS _ 58) }
  'writeInt' { PT _ (TS _ 59) }
  'writeString' { PT _ (TS _ 60) }
  '{' { PT _ (TS _ 61) }
  '}' { PT _ (TS _ 62) }
  '~=' { PT _ (TS _ 63) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_LIdent { PT _ (T_LIdent _) }

-- tipi per gli attributi di $$
%attributetype { AttrTree a }
%attribute res { Result }
%attribute parsetree { a }
%attribute vint { Integer }
%attribute vdbl { Double }
%attribute vchr { Char }
%attribute vstr { String }
%attribute vlident { LIdent }

-- attributi per il frontend
%attribute envin { EnvT }       -- env più esterno
%attribute envloc { EnvT }      -- env del blocco locale
%attribute envout { EnvT }      -- env del blocco uscente
%attribute errs { [String] }
%attribute posn { Posn }
%attribute tipo { CmpType }
%attribute listparf { [(ParamF,Posn,String)] }
%attribute parname { String }
%attribute lrexptpe { [CmpType] }



-- attributi per TAC
%attribute code {[TAC]}
%attribute condTrue { LabelTac }
%attribute condFalse { LabelTac }
%attribute statein { State }
%attribute stateout { State }
%attribute addr { ArgOp }
%attribute nextLabel { LabelTac }
%attribute listDim { [ArgOp] }
%attribute listElem { [ArgOp] }
%attribute listRexp { [ArgOp] }

%%

Integer : L_integ  
            { 
              $$.vint = (read ( $1)) :: Integer
              ; $$.tipo = Base BasicType_Int
      		  ; $$.addr = IntTac ((read $1) :: Int)
      		  ; $$.stateout = $$.statein
            }
Double : L_doubl   { 
              $$.vdbl = (read ( $1)) :: Double 
              ; $$.tipo = Base BasicType_Float
      		  ; $$.addr = FloatTac ((read $1) :: Double)
      		  ; $$.stateout = $$.statein
            }
String : L_quoted  {
              $$.vstr = $1
              ; $$.tipo = Base BasicType_String
      		  ; $$.addr = StringTac $1
      		  ; $$.stateout = $$.statein  
            }
Char : L_charac {
              $$.vchr = (read ( $1)) :: Char 
              ; $$.tipo = Base BasicType_Char
      		  ; $$.addr = CharTac ((read $1) :: Char)
      		  ; $$.stateout = $$.statein
            }
LIdent : L_LIdent 
    {         
            $$.posn =  (tokenPosn $1)                           
            ; $$.vlident = LIdent (getLIdentT $1)
            ; $$.addr = NameTac (getLIdentT $1) (if isNothing(lookupEnv (getLIdentT $1) $$.envin)
                                                    then $$.posn
                                                    else ((getPos . fromJust) (lookupEnv (getLIdentT $1) $$.envin)))
            ; $$.stateout = $$.statein
            ; $$.code = []
    }

Program : ListPGlobl
    { 
        $1.envin = emptyEnv
        ; $1.envloc = emptyEnv
        ; $1.statein = (1,1)
        ; $$.res = Result (AbsAuL.Prog $1.parsetree ) $1.code $1.envout $1.errs
    }

ListPGlobl : PGlobl 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = (:[]) $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    } 
    | PGlobl ListPGlobl
    { 
        $1.envin = $$.envin
        ; $2.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $2.envloc = $1.envout
        ; $$.parsetree = (:) $1.parsetree $2.parsetree
        ; $$.envout = $2.envout
        ; $$.errs = $1.errs ++ $2.errs
        ; $1.statein = $$.statein
        ; $2.statein = $1.stateout
        ; $$.stateout = $2.stateout
        ; $$.code = $1.code ++ $2.code
        
    }

PGlobl : Stm 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.ProgGlobB $1.parsetree
        ; $$.envout = $1.envout 
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
       | FuncD 
    { 
        $$.parsetree = AbsAuL.ProgGlobF $1.parsetree
        ; $1.envloc = $$.envloc
        ; $1.envin = $$.envin 
        ; $$.envout = $1.envout 
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.errs = $1.errs
        ; $$.code = $1.code
    }

--  ========================
--  =======  BLKS  =========
--  ========================

Block : ListStm 
    { 
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $1.envloc = if (isJust (lookupEnv "return" $$.envloc))
                         then (reinsertRetEnv 
                                ((getTypeR . fromJust) (lookupEnv "return" $$.envloc))
                                ((foundIstr . fromJust) (lookupEnv "return" $$.envloc))
                                (if (isJust ((lookupEnv "break" $$.envloc)))
                                    then (insertBreakEnv ((label . fromJust) (lookupEnv "break" $$.envloc)) emptyEnv)
                                    else emptyEnv))
                         else emptyEnv
        ; $$.parsetree = AbsAuL.Blk $1.parsetree
        ; $$.envout = if (isJust (lookupEnv "return" $$.envloc))
                         then (reinsertRetEnv 
                                    ((getTypeR . fromJust) (lookupEnv "return" $1.envout))
                                    ((foundIstr . fromJust) (lookupEnv "return" $1.envout))
                                    $$.envloc)
                         else $$.envloc
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
-- N.d.R.: Per necessità di non switchare il envloc ed envin dichiaro una regola
-- fittizia al fine di ottenere il medesimo tipo e non stravolgere l'AST
BlockF : ListStm 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.Blk $1.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = (if (isJust (lookupEnv "return" $1.envout))
                    then (if (((getTypeR . fromJust) (lookupEnv "return" $1.envout)) == ErrT)
                             then []
                             else (if ((foundIstr . fromJust) (lookupEnv "return" $1.envout))
                                    then []
                                    else ["error: statement return not found in function definition!"]))
                    else ["Compiler Frontend General Error: listen to me, you must go to sleep..."]) ++ $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code        
    }
ListStm : {- empty -} 
    { 
        $$.parsetree = [] 
        ; $$.envout = $$.envloc
        ; $$.errs = []
        ; $$.code = []        
        ; $$.stateout = $$.statein
    } 
    | ListStm Stm
    { 
        $1.envin = $$.envin
        ; $2.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $2.envloc = $1.envout
        ; $$.parsetree =  flip (:) $1.parsetree $2.parsetree
        ; $$.envout = $2.envout
        ; $$.errs = $1.errs ++ $2.errs
        ; $1.statein = $$.statein
        ; $2.statein = $1.stateout
        ; $$.stateout = $2.stateout
        ; $$.code = $1.code ++  $2.code
    }

--  ========================
--  ======= TIPI   =========
--  ========================

BasicType : 'Bool' 
    { 
        $$.parsetree = AbsAuL.BasicType_Bool 
        ; $$.code = []
    }
    | 'Char' 
    { 
        $$.parsetree = AbsAuL.BasicType_Char 
        ; $$.code = []
    }
    | 'Float' 
    { 
        $$.parsetree = AbsAuL.BasicType_Float 
        ; $$.code = []
    }
    | 'Int' 
    { 
        $$.parsetree = AbsAuL.BasicType_Int 
        ; $$.code = []
    }
    | 'String' 
    { 
        $$.parsetree = AbsAuL.BasicType_String 
        ; $$.code = []
    }
    | 'Void' 
    { 
        $$.parsetree = AbsAuL.BasicType_Void 
        ; $$.code = []
    }

Boolean : 'true' { $$.parsetree = AbsAuL.Boolean_true 
                   ; $$.tipo = Base BasicType_Bool
                   ; $$.stateout = $$.statein
                   ; $$.code = []
                   ; $$.addr = BoolTac True
                }
        | 'false' { $$.parsetree = AbsAuL.Boolean_false 
                    ; $$.tipo = Base BasicType_Bool
                    ; $$.stateout = $$.statein
                    ; $$.code = [] 
                   ; $$.addr = BoolTac False
                }

PtrVoid : 'nil' { $$.parsetree = AbsAuL.PtrType 
                  ; $$.code = [] }

--MODDED per nuova grammatica             
CompoundType : BasicType 
                { 
                    $$.parsetree =  AbsAuL.CompTypeB $1.parsetree 
                    ; $$.code = $1.code
                }

             | '*' CompoundType 
                { 
                    $$.parsetree =  AbsAuL.CompTypeP $2.parsetree 
                    ; $$.code = $2.code
                }
             | BasicType ListBracks 
               { 
                   $$.parsetree =  AbsAuL.CompTypeA $1.parsetree $2.parsetree 
                   ; $$.code = $1.code ++ $2.code
                }

Bracks : '[' ']' { $$.parsetree = AbsAuL.Brack }

ListBracks : Bracks { $$.parsetree =  (:[]) $1.parsetree } 
             | Bracks ListBracks { $$.parsetree =  (:) $1.parsetree $2.parsetree }

--  ========================
--  =======  STM   =========
--  ========================

Stm : Decl ';' -- nextLabel da gestire per lazyness in varinit
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SDecl $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
    | Local ';' 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SLocal $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
    | Ass ';' -- nextLabel da gestire pper lazyness in rexp
    { 
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $$.parsetree = AbsAuL.SAss $1.parsetree 
        ; $$.envout = $$.envloc
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
    | While 
    { 
        $1.envin = $$.envin
        ; $1.envloc = insertBreakEnv $1.nextLabel $$.envloc
        ; $$.parsetree = AbsAuL.SWhile $1.parsetree
        ; $$.envout = if (isJust (lookupEnv "break" $$.envin)) 
                         then (insertBreakEnv ((label . fromJust) (lookupEnv "break" $$.envin)) (deleteEnv "break" $1.envout))
                         else (deleteEnv "break" $1.envout)
        ; $$.errs = $1.errs
        ; $1.nextLabel = genlabel $$.statein 0
        ; $1.statein = skipState $$.statein 0 1
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
    | Repeat ';'
    {
        $1.envin = $$.envin
        ; $1.envloc = insertBreakEnv $1.nextLabel $$.envloc
        ; $$.parsetree = AbsAuL.SRepeat $1.parsetree
        ; $$.envout = if (isJust (lookupEnv "break" $$.envin)) 
                         then (insertBreakEnv ((label . fromJust) (lookupEnv "break" $$.envin)) (deleteEnv "break" $1.envout))
                         else (deleteEnv "break" $1.envout)
        ; $$.errs = $1.errs  
        ; $1.nextLabel = genlabel $$.statein 0
        ; $1.statein = skipState $$.statein 0 1
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
    | For 
    {
        $1.envin = $$.envin
        ; $1.envloc = insertBreakEnv $1.nextLabel $$.envloc
        ; $$.parsetree = AbsAuL.SFor $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = if (isJust (lookupEnv "break" $$.envin)) 
                         then (insertBreakEnv ((label . fromJust) (lookupEnv "break" $$.envin)) (deleteEnv "break" $1.envout))
                         else (deleteEnv "break" $1.envout)
        ; $1.nextLabel = genlabel $$.statein 0
        ; $1.statein = skipState $$.statein 0 1
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
    | If 
    { 
        $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SIf $1.parsetree 
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code

    }
    | Func ';' 
    { 
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $$.parsetree = AbsAuL.SRExp $1.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
    | EBlk 
    {
        $1.envin = mergeEnv $$.envloc $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SEBlk $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
    | Return ';'
    { 
       $1.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.SReturn $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }
    | Break ';' 
    {   
        $$.parsetree = AbsAuL.SBreak $1.parsetree
        ; $$.envout = $$.envloc
        ; $1.envloc = mergeEnv $$.envloc $$.envin
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
    }

--  ========================
--  =======  EBLK  =========
--  ========================
EBlk : 'do' Block 'end' 
    { 
        $2.envin = $$.envin
        ; $2.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.EBlkS $2.parsetree
        ; $$.errs = $2.errs
        ; $$.envout = $2.envout
        ; $2.statein = $$.statein
        ; $$.stateout = $2.stateout
        ; $$.code = $2.code
    }

--  ========================
--  =======  DECL  =========
--  ========================
Decl : BasicType LExp VarInit 
    { 
        $2.envin = emptyEnv
        ; $3.envin = (mergeEnv $$.envloc $$.envin)
        ; $3.tipo = makeCmpType (getPtrLev $2.parsetree) (getArrLev $2.parsetree) $1.parsetree
        ; $$.parsetree = AbsAuL.DeclSP $1.parsetree $2.parsetree $3.parsetree
        ; $$.envout = ( if (isOk (insertEnv $1.parsetree Modality1 $2.parsetree $$.envloc $2.posn))
                         then (fromOk (insertEnv $1.parsetree Modality1 $2.parsetree $$.envloc $2.posn))
                         else $$.envloc)
        ; $$.errs = ( if (isJust (lookupEnv ( (fromLIdent . getLIdentlexp) $2.parsetree) $$.envloc))
                         then ["error at "++ (showFromPosn $2.posn) ++": variable " ++ 
                                (fromBad (insertEnv $1.parsetree Modality1 $2.parsetree $$.envloc $2.posn))]
                         else []
                        ) ++ $2.errs ++ $3.errs ++
                    (if ($1.parsetree == BasicType_Void)
                        then ["error at "++ (showFromPosn $2.posn) ++": variable type is 'Void', type not permitted!"]
                        else [])
        ; $$.tipo = makeCmpType (getPtrLev $2.parsetree) (getArrLev $2.parsetree) $1.parsetree
        ; $2.statein = $$.statein
        ; $3.statein = $2.stateout
        ; $$.addr = $2.addr
        ; $$.stateout = if $3.parsetree == AbsAuL.VarINil then $3.stateout
                        else skipState $2.stateout 1 0
        ; $$.code = if (isArrayType $$.tipo && $3.parsetree == AbsAuL.VarINil)  then [(Rules (ArrayDef (toTACType $$.tipo) $2.addr))] ++ listDimToTac $2.listDim ++ $2.code
                        else if (isArrayType $$.tipo) then [(Rules (ArrayDef (toTACType $$.tipo) $2.addr))] ++ listDimToTac $2.listDim ++ $2.code ++ $3.code 
	                    else if $3.parsetree == AbsAuL.VarINil then [(Rules (VarDecl (toTACType $$.tipo) $2.addr))]
                        else if (isPointerType $$.tipo) then $2.code ++ $3.code 
                           else  [(Rules (Assgm (toTACType $$.tipo) $2.addr (gentemp $2.stateout 0)))] ++ $3.code 
        
    }

VarInit : {- empty -}
    { 
        
        $$.parsetree = AbsAuL.VarINil
        ; $$.errs = []
        ; $$.stateout = $$.statein
        ; $$.tipo = Base BasicType_Void
    }
    | '=' RExp 
    {
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.VarExp $2.parsetree 
        ; $$.errs = (if (not ($2.tipo == ErrT))
                        then if (compCmpType $$.tipo $2.tipo) == ErrT
                                then ["error at "++ ((showFromPosn . tokenPosn) $1) ++ ": cannot assign '" ++ (showCmpType $2.tipo) ++
                                        "' to a variable with type '"++(showCmpType $$.tipo)++"'"]
                                else []
                        else [])++ $2.errs
        ; $2.statein = $$.statein
        ; $$.stateout = if $$.tipo == $2.tipo then $2.stateout
                                              else skipState $2.stateout 1 0
        ; $$.code = if $2.code == [] then 
                        if (isPointerType $$.tipo) then [Rules (Assgm (toTACType $$.tipo) (gentemp $2.statein 0) $2.addr)]
                        else if (not $ ($$.tipo == $2.tipo)) then [Rules (Cast (gentemp $$.statein 0) (toTACType $$.tipo) (toTACType $2.tipo) $2.addr)] 
                                                             else [Rules (Assgm (toTACType $$.tipo) (gentemp $2.statein 0) $2.addr)]
                    else $2.code
    }
    | '=' Array 
    { 
        $$.parsetree = AbsAuL.VarMat $2.parsetree
        ; $$.errs  = (controlArrTipo $$.tipo $2.parsetree $1)
        ; $$.code = listElemToTac $2.listElem
    }


Array : '{' ListArray '}'
    { 
        $$.parsetree = AbsAuL.ArrayV0 $2.parsetree 
        ; $$.listElem = $2.listElem
        ; $$.code = listElemToTac $2.listElem
    }
    | '{' ListVType '}' 
    { 
        $$.parsetree = AbsAuL.ArrayV1 $2.parsetree 
        ; $$.listElem = $2.listElem
    }
VType : Boolean 
    { 
        $$.parsetree = AbsAuL.VTypeBoolean $1.parsetree 
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
    | Char --modded
    { 
        $$.parsetree = AbsAuL.VTypeChar $1.vchr 
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
    | Double --modded
    { 
        $$.parsetree = AbsAuL.VTypeDouble $1.vdbl 
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
    | Integer --modded
    { 
        $$.parsetree = AbsAuL.VTypeInteger $1.vint
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
    | String --modded
    { 
        $$.parsetree = AbsAuL.VTypeString $1.vstr 
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
    | PtrVoid 
    { 
        $$.parsetree = AbsAuL.VTypePtrVoid $1.parsetree 
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
ListVType : VType 
    { 
        $$.parsetree = (:[]) $1.parsetree 
        ; $$.listElem = [$1.addr]
    } 
    | VType ',' ListVType 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree 
        ; $$.listElem = (:) $1.addr $3.listElem 
    }
ListArray : Array 
    { 
        $$.parsetree = (:[]) $1.parsetree 
        ; $$.listElem = $1.listElem
    } 
    | Array ',' ListArray 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree
        ; $$.listElem = $1.listElem ++ $3.listElem 
    }

--  ========================
--  =======  LOCL  =========
--  ========================

Local : 'local' Decl 
    { 
        $2.envin = (mergeEnv $$.envloc $$.envin)
        ; $2.envloc = emptyEnv
        ; $$.parsetree = AbsAuL.DeclLocal $2.parsetree 
        ; $$.envout = (mergeEnv $2.envout $$.envloc)
        ; $$.errs = $2.errs
        ; $2.statein = $$.statein 
        ; $$.stateout = $2.stateout 
        ; $$.code = [(Rules (Local $2.addr))] ++ $2.code
    }

--  ========================
--  =======  ASSG  =========
--  ========================

Ass : LExp '=' RExp -- TODO: finisci errori
    { 
         $3.envin = $$.envin
        ; $1.envin = $$.envin
        ; $$.parsetree = AbsAuL.AssD $1.parsetree $3.parsetree
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                        then if ((not . isFnctEnv . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                then (downCmpType (getPtrLev $1.parsetree) (getArrLev $1.parsetree)
                                        ((fst . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin)))
                                else ErrT 
                        else ErrT)
        ; $$.errs = (if ($$.tipo == ErrT)
                         then (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                 then (if ((not . isFnctEnv . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                          then ["error at "++ ((showFromPosn . tokenPosn) $2) ++": dereferencing level is inadequate!"]
                                          else ["error at "++ ((showFromPosn . tokenPosn) $2) ++": cannot assign value to a function!"])
                                 else ["error at "++ ((showFromPosn . tokenPosn) $2) ++": refer to unexistent variable!"])
                         else if (not ((compCmpType $$.tipo $3.tipo) == ErrT))
                                  then if((snd . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin) == Modality_const)
                                         then ["error at " ++ ((showFromPosn . tokenPosn) $2) ++
                                               ": cannot assign value to a constant variable "++
                                               ((fromLIdent . getLIdentlexp) $1.parsetree) ++"!"]
                                         else []
                                  else ["error at " ++ ((showFromPosn . tokenPosn) $2) ++ 
                                        ": expects argument of type '" ++ (showCmpType $$.tipo) ++ 
                                        "' but has type '"++ (showCmpType $3.tipo) ++"'"]) ++ $1.errs ++ $3.errs
        ; $1.statein = $$.statein
        ; $3.statein = $1.stateout
        ; $$.stateout = skipState $3.stateout 0 2
        ; $$.code = if (not ($3.tipo == $$.tipo)) then [Rules (Cast (gentemp $$.statein 0) (toTACType $$.tipo) (toTACType $3.tipo) $3.addr)] 
                                                        ++ [(Rules (Assgm (toTACType $$.tipo) $1.addr (gentemp $$.statein 0) ))]
                                                   else [(Rules (Assgm (toTACType $$.tipo) $1.addr (gentemp $3.statein 0)))] ++ 
                                                        (if (null $1.listDim) then [] else listDimToTac $1.listDim) ++
                                                        [(Rules (Assgm (toTACType $$.tipo) (gentemp $3.statein 0) $3.addr))] ++ $3.code
    }
    
--  ========================
--  =======  FUNC  =========
--  ========================
--TODO: rivedi in lident'('[listrexp]')'

Func : FuncWrite 
    { 
        $1.envin = $$.envin
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.parsetree = AbsAuL.FuncBW $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = Base BasicType_Void
        ; $$.code = $1.code
    }
    | FuncRead 
    { 
        $1.envin = $$.envin
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.parsetree = AbsAuL.FuncBR $1.parsetree 
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
        ; $$.code = $1.code
    }
    | LIdent '(' ListRExp ')' --modded -> controllare tipo ritorno
    { 
        $$.parsetree = AbsAuL.FnctCall $1.vlident $3.parsetree
        ; $3.envin = $$.envin
        ; $$.tipo = if (isJust (lookupEnv (fromLIdent $1.vlident) $$.envin))
                        then (if ((isFnctEnv . fromJust) (lookupEnv (fromLIdent $1.vlident) $$.envin))
                              then ((getTypeF . fromJust) (lookupEnv (fromLIdent $1.vlident) $$.envin))
                              else ErrT)
                        else ErrT
        ; $$.errs = (if (isJust (lookupEnv (fromLIdent $1.vlident) $$.envin))
                        then (if ((isFnctEnv . fromJust) (lookupEnv (fromLIdent $1.vlident) $$.envin))
                              then (controlFnctTipo
                                        (map (\x -> (fst . getType) x) 
                                            ((getParamF . fromJust) (lookupEnv (fromLIdent $1.vlident) $$.envin)))
                                        $3.lrexptpe
                                        $1.posn
                                   )
                              else ["error at "++(showFromPosn $1.posn)++": "++(fromLIdent $1.vlident)++"isn't defined as function!"])
                        else ["error at "++(showFromPosn $1.posn)++": function "++(fromLIdent $1.vlident)++"is undefined!"]) ++ $3.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.addr = $1.addr
        ; $$.code = [(Rules (FuncCall (gentemp $1.stateout 0) IntTypeTac (InternalFunc (argOpToString $1.addr)) (length $3.listRexp)))] ++ listRexpToTac $3.listRexp
    }
ListRExp : {- empty -} 
    { 
        $$.parsetree = [] 
        ; $$.lrexptpe = []
        ; $$.listRexp = []
        ; $$.errs = []
    }
    | RExp 
    { 
        $$.parsetree = (:[]) $1.parsetree 
        ; $1.envin = $$.envin
        ; $$.lrexptpe = (:[]) $1.tipo
        ; $$.errs = $1.errs
        ; $$.listRexp = (:[]) $1.addr
    }
    | RExp ',' ListRExp 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree 
        ; $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.lrexptpe = (:) $1.tipo $3.lrexptpe
        ; $$.listRexp = (:) $1.addr $3.listRexp
        ; $$.errs = $1.errs ++ $3.errs
    }

FuncWrite : 'writeInt' '(' RExp ')' 
    { 
        $3.envin = $$.envin

        ; $$.parsetree = AbsAuL.WriteI $3.parsetree
        ; $$.errs = (if (not($3.tipo == Base BasicType_Int))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeInt' need to be Int!"]
                        else []
                     ) ++ $3.errs
        ;$3.statein = $$.statein
        ; $$.stateout = skipState $3.stateout 1 0
        ; $$.code = $3.code ++ [(Rules (Assgm IntTypeTac (gentemp $3.stateout 1)  $3.addr)),(Rules(Load (gentemp $3.stateout 1))), (Rules(ProcCall WriteInt 1))]
    }
    | 'writeFloat' '(' RExp ')' 
    { 
        $3.envin = $$.envin

        ; $$.parsetree = AbsAuL.WriteF $3.parsetree
        ; $$.errs = (if (not ($3.tipo == Base BasicType_Float))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeFloat' need to be Float!"]
                        else []
                     ) ++ $3.errs
        ;$3.statein = $$.statein
        ; $$.stateout = skipState $3.stateout 1 0
        ; $$.code = $3.code ++ [(Rules (Assgm FloatTypeTac (gentemp $3.stateout 1)  $3.addr)),(Rules(Load (gentemp $3.stateout 1))), (Rules(ProcCall WriteFloat 1))]
    }
    | 'writeChar' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.WriteC $3.parsetree
        ; $$.errs = (if (not ($3.tipo == Base BasicType_Char))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeChar' need to be Char!"]
                        else []
                     ) ++ $3.errs
        ;$3.statein = $$.statein
        ; $$.stateout = skipState $3.stateout 1 0
        ; $$.code = $3.code ++ [(Rules (Assgm CharTypeTac (gentemp $3.stateout 1)  $3.addr)),(Rules(Load (gentemp $3.stateout 1))), (Rules(ProcCall WriteChar 1))]
    }
    | 'writeString' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.WriteS $3.parsetree
        ; $$.errs = (if (not ($3.tipo == Base BasicType_String))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeString' need to be String!"]
                        else []
                     ) ++ $3.errs
        ;$3.statein = $$.statein
        ; $$.stateout = skipState $3.stateout 1 0
        ; $$.code = $3.code ++ [(Rules (Assgm StringTypeTac (gentemp $3.stateout 1)  $3.addr)),(Rules(Load (gentemp $3.stateout 1))), (Rules(ProcCall (InternalFunc "writeString") 1))]
    }

FuncRead : 'readInt' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadI
        ; $$.tipo = Base BasicType_Int
        ; $$.errs = []
        ; $$.posn = tokenPosn $1
        ; $$.addr = (gentemp $$.statein 1)
        ; $$.stateout = skipState $$.statein 1 0
        ; $$.code = [(Rules (FuncCall $$.addr CharTypeTac ReadInt 0))]
    }   
    | 'readFloat' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadF
        ; $$.tipo = Base BasicType_Float
        ; $$.errs = []
        ; $$.posn = tokenPosn $1
        ; $$.addr = (gentemp $$.statein 1)
        ; $$.stateout = skipState $$.statein 1 0
        ; $$.code = [(Rules (FuncCall $$.addr CharTypeTac ReadFloat 0))]
    }
    | 'readChar' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadC
        ; $$.tipo = Base BasicType_Char
        ; $$.errs = []
        ; $$.posn = tokenPosn $1
        ; $$.addr = (gentemp $$.statein 1)
        ; $$.stateout = skipState $$.statein 1 0
        ; $$.code = [(Rules (FuncCall $$.addr CharTypeTac ReadChar 0))]
    }
    | 'readString' '(' ')' 
    { 
        $$.parsetree = AbsAuL.ReadS
        ; $$.tipo = Base BasicType_String
        ; $$.errs = []
        ; $$.posn = tokenPosn $1
        ; $$.addr = (gentemp $$.statein 1)
        ; $$.stateout = skipState $$.statein 1 0
        ; $$.code = [(Rules (FuncCall $$.addr StringTypeTac ReadString 0))]
    }

--  ========================
--  =======  WHILE  =========
--  ========================

While : 'while' RExp EBlk 
    { 
       $2.envin = mergeEnv $$.envloc $$.envin
        ; $3.envin = $$.envin
        ; $3.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.LoopW $2.parsetree $3.parsetree
        ; $$.envout = $3.envout
        ; $$.errs = (if (op2CompType EqO (Base BasicType_Bool) $2.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": 'while' condition need to be 'Bool' expression!"]
                        else []) ++ $2.errs ++ $3.errs
        ; $2.statein = $$.statein
        ; $3.statein = $2.stateout
        ; $$.stateout = skipState $3.stateout 0 2
        ; $2.condTrue = (genlabel $3.stateout 2)
        ; $2.condFalse = $$.nextLabel
        ; $3.nextLabel = $$.nextLabel
        ; $$.code = (labelRules (genlabel $3.stateout 1) $2.code) ++ 
                    [(Rules (CondTrue $2.addr $2.condTrue))] ++
                    [(Rules (CondFalse $2.addr $2.condFalse))] ++
                    (labelRules $2.condTrue $3.code) ++ 
                    [(Rules (Goto (genlabel $3.stateout 1)))] ++
                    (labelRules $$.nextLabel [])
    }

--  ========================
--  =======  REPT  =========
--  ========================

Repeat : 'repeat' Block 'until' RExp 
    { 
          $2.envin = $$.envin
        ; $2.envloc = $$.envloc
        ; $4.envin = mergeEnv $$.envloc $$.envin
        ; $$.parsetree = AbsAuL.LoopR $2.parsetree $4.parsetree
        ; $$.envout = $2.envout
        ; $$.errs = (if (op2CompType EqO (Base BasicType_Bool) $4.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": 'repeat' condition need to be 'Bool' expression!"]
                        else []) ++ $2.errs ++ $4.errs
        ; $2.statein = $$.statein
        ; $4.statein = $2.stateout
        ; $$.stateout = skipState $4.stateout 0 2
        ; $4.nextLabel = $$.nextLabel
        ; $4.condTrue = (genlabel $2.stateout 2)
        ; $4.condFalse = $$.nextLabel
        ; $$.code = (labelRules $4.condTrue $2.code) ++ $4.code ++
                    [(Rules (CondTrue $4.addr $4.condTrue))] ++ 
                    [(Rules (CondFalse $4.addr $4.condFalse))] ++ 
                    (labelRules $$.nextLabel [])                     
    }

--  ========================
--  =======  FORS  =========
--  ========================

For : 'for' LIdent '=' RExp ',' RExp Increment EBlk -- ; $$.envout = deleteEnv (fromLIdent $2.parsetree) $8.envout
    { 
        $4.envin = mergeEnv $$.envloc $$.envin
        ; $2.envin = emptyEnv
        ; $6.envin = mergeEnv $$.envloc $$.envin
        ; $7.envin = mergeEnv $$.envloc $$.envin
        ; $8.envin = $$.envin
        ; $8.envloc = if((all (\(x,y) -> x == y ) [($4.tipo,$6.tipo),($6.tipo,$7.tipo),($7.tipo,$4.tipo)]) )
                        then (mergeEnv (fromOk (insertEnv (getBaseType $7.tipo) Modality1 (LExpS $2.vlident) emptyEnv $2.posn)) $$.envloc)
                        else (mergeEnv (fromOk (insertEnv (getBaseType $4.tipo) Modality1 (LExpS $2.vlident) emptyEnv $2.posn)) $$.envloc)
        ; $$.parsetree = AbsAuL.LoopF $2.vlident $4.parsetree $6.parsetree $7.parsetree $8.parsetree
        ; $$.envout = $$.envloc
        ; $$.errs = (if ( all (\(x,y) -> x == y ) [($4.tipo,$6.tipo),($6.tipo,$7.tipo),($7.tipo,$4.tipo)])
                        then []
                        else ["error at "++ (showFromPosn $2.posn) ++": incompatible types in 'for' loop conditions!"])
                               ++ $4.errs ++ $6.errs ++ $7.errs ++ $8.errs
                               ++ $4.errs ++ $6.errs ++ $7.errs ++ $8.errs
        
        ; $2.statein = $$.statein
        ; $4.statein = $2.stateout
        ; $6.statein = skipState $4.stateout 1 1
        ; $7.statein = $6.stateout
        ; $8.statein = if ($7.code == []) then skipState $6.stateout 1 0
                                          else skipState $7.stateout 1 0
        ; $$.stateout = skipState $8.stateout 0 2
        ; $6.condTrue = (genlabel $8.stateout 2)
        ; $6.condFalse = $$.nextLabel
        ; $8.nextLabel = $$.nextLabel
        ; $$.code = [(Rules (Assgm (toTACType $4.tipo) $2.addr (gentemp $2.stateout 1)))] ++ [(Rules (Assgm (toTACType $4.tipo) (gentemp $2.stateout 1) $4.addr))] ++ $4.code 
                    ++ (labelRules (genlabel $8.stateout 1) $6.code) ++
                    (labelRules $6.condTrue $8.code) ++ (if (null $7.code) then [(Rules (AssgmBin (toTACType $4.tipo) $2.addr $2.addr (binop TAC.Add (toTACType $4.tipo)) (IntTac 1) ))]
                                                                           else $7.code)
                    ++ [(Rules (CondTrue $6.addr $6.condTrue))] ++ [(Rules (CondFalse $6.addr $6.condFalse))] 
                    ++ (labelRules $8.nextLabel [])
    }

Increment : {- empty -} -- per l'appunto, assumiamo sia 1 l'incremento
    { 
        $$.parsetree = AbsAuL.FIncE
        ; $$.tipo = Base BasicType_Int
        ; $$.errs = []
        ; $$.stateout = $$.statein
        ; $$.code = []
    }
    | ',' RExp 
    { 
        $$.parsetree = AbsAuL.FInc $2.parsetree
        ; $2.envin = $$.envin
        ; $$.tipo = $2.tipo
        ; $$.errs = $2.errs
        ; $2.statein = skipState $$.statein 1 0
        ; $$.stateout = $2.stateout
        ; $$.code = $2.code
    }
    
--  ========================
--  =======   IF   =========
--  ========================
If : 'if' RExp 'then' Block ListElseIf Else 'end'
    { 
         $2.envin = mergeEnv $$.envloc $$.envin
        ; $4.envin = $$.envin
        ; $5.envin = $$.envin
        ; $6.envin = $$.envin
        ; $4.envloc = $$.envloc
        ; $5.envloc = $4.envout
        ; $6.envloc = $5.envout
        ; $$.parsetree = AbsAuL.IfM $2.parsetree $4.parsetree (reverse $5.parsetree) $6.parsetree
        ; $$.envout = $6.envout
        ; $$.errs = (if (op2CompType EqO (Base BasicType_Bool) $2.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": 'if' condition need to be 'Bool' expression!"]
                        else []) ++ $2.errs ++ $4.errs ++ $5.errs ++ $6.errs
        
        ; $2.statein = $$.statein 
        ; $4.statein = skipState $2.stateout 0 0
        ; $5.statein = $4.stateout
        ; $6.statein = $5.stateout
        
        ; $5.nextLabel = genlabel $6.stateout 0
        
        ; $2.condFalse = (genlabel $4.stateout 0)
        
        ; $$.stateout = skipState $6.stateout 0 1
        
        ; $$.code = $2.code ++ [(Rules (CondFalse $2.addr $2.condFalse))] ++ 
                               $4.code ++ 
                               [(Rules (Goto (genlabel $6.stateout 0)))] ++
                               $5.code ++ 
                               $6.code ++
                               (labelRules (genlabel $6.stateout 0) [])
    }

Else : 'else' Block 
    { 
        $2.envin = $$.envin
        ; $2.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.ElseS $2.parsetree
        ; $$.errs = $2.errs
        ; $$.envout = $2.envout
        ; $2.statein = skipState $$.statein 0 1
        ; $$.stateout = $2.stateout
        ; $$.code = (labelRules (genlabel $$.statein 0) $2.code) 
    }
    | {- empty -} --; $$.code = (labelRules (genlabel $$.statein 0) [])
    { 
        $$.parsetree = AbsAuL.ElseE
        ; $$.envout = $$.envloc
        ; $$.stateout = $$.statein 
        ; $$.errs = []
        ; $$.code = []
    }

ElseIf : 'elseif' RExp 'then' Block 
    { 
        $2.envin = mergeEnv $$.envloc $$.envin
        ; $4.envin = $$.envin
        ; $4.envloc = $$.envloc
        ; $$.parsetree = AbsAuL.ElseIfD $2.parsetree $4.parsetree
        ; $$.envout = $4.envout
        ; $$.errs = (if (ErrT == $2.tipo)
                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": 'elseif' condition need to be 'Bool' expression!"]
                        else []) ++ $2.errs ++ $4.errs
        
        ; $2.statein = $$.statein
        ; $4.statein = skipState $2.stateout 0 0
        
        ; $$.stateout = skipState $4.stateout 0 0
        
        ; $2.condFalse = (genlabel $4.stateout 0)
        
        ; $$.code = $2.code ++
                    [(Rules (CondFalse $2.addr $2.condFalse))] ++
                    $4.code ++ [(Rules (Goto $$.nextLabel))] 
    }

ListElseIf : {- empty -} 
    { 
        $$.parsetree = []
        ; $$.envout = $$.envloc
        ; $$.stateout = $$.statein
        ; $$.errs = [] 
        ; $$.code = []
    }
    | ListElseIf ElseIf 
    { 
        $1.envin = $$.envin
        ; $2.envin = $$.envin
        ; $1.envloc = $$.envloc
        ; $2.envloc = $1.envout
        ; $$.envout = $2.envout
        ; $$.parsetree = flip (:) $1.parsetree $2.parsetree
        ; $$.errs = $1.errs ++ $2.errs
        ; $1.statein = $$.statein
        ; $2.statein = skipState $1.stateout 0 1
        ; $$.stateout = $2.stateout 
        ; $1.nextLabel = $$.nextLabel
        ; $2.nextLabel = $$.nextLabel
        ; $$.code = $1.code ++ (labelRules (genlabel $1.stateout 0) $2.code) 
    }

--  ========================
--  =======  JUMP  =========
--  ========================

Return : 'return' RValue 
    { 
        $$.parsetree = AbsAuL.JumpR $2.parsetree 
        ; $2.envin = $$.envin
        ; $2.envloc = $$.envloc
        ; $2.posn = (tokenPosn $1)
        ; $$.envout = if (isJust (lookupEnv "return" $$.envloc))
                         then (reinsertRetEnv ((getTypeR . fromJust) (lookupEnv "return" $$.envloc)) True $$.envloc)
                         else $$.envloc
        ; $$.errs = $2.errs
        ; $2.nextLabel = $$.nextLabel
        ; $2.statein = $$.statein
        ; $$.stateout = $2.stateout
        ; $$.code = $2.code
    }

RValue : {- empty -} 
    { 
        $$.parsetree = AbsAuL.JumpRE
        ; $$.errs = if (isJust (lookupEnv "return" $$.envloc))
                        then (if (((getTypeR . fromJust) (lookupEnv "return" $$.envloc)) == ErrT)
                                then []
                                else ["error at "++ (showFromPosn $$.posn) ++ ": empty return, but need '"++
                                      (showCmpType ((getTypeR . fromJust) (lookupEnv "return" $$.envloc))) ++
                                      "' expression type!"] )
                        else ["error at " ++ (showFromPosn $$.posn) ++ ": return statement out of function!"]
        ; $$.stateout = $$.statein
        ; $$.code = [(Rules (Goto $$.nextLabel))]    
    }
    | RExp 
    { 
        $$.parsetree = AbsAuL.JumpRV $1.parsetree
        ; $1.envin = mergeEnv $$.envloc $$.envin
        ; $$.errs = (if (isJust (lookupEnv "return" $$.envloc))
                        then (if ((getTypeR . fromJust) (lookupEnv "return" $$.envloc) == ErrT)
                                 then ["error at " ++ (showFromPosn $$.posn) ++ ": return is Void, but given expression's type is '" ++
                                        (showCmpType $1.tipo) ++ "'"]
                                 else (if (not (ErrT == (compCmpType ((getTypeR . fromJust) (lookupEnv "return" $$.envloc)) $1.tipo)))
                                          then []
                                          else ["error at "++ (showFromPosn $$.posn) ++ ": return need '"++ 
                                                (showCmpType ((getTypeR . fromJust) (lookupEnv "return" $$.envloc))) ++
                                                "', but given '"++ (showCmpType $1.tipo) ++ "' expression type!"]))
                        else ["error at " ++ (showFromPosn $$.posn) ++ ": return statement out of function!"]) ++ $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = [(Rules (ReturnTac $1.addr))]
    }

Break : 'break' 
    { 
        $$.parsetree = AbsAuL.JumpB
        ; $$.envout = $$.envloc
        ; $$.errs = if (isNothing (lookupEnv "break" $$.envloc))
                    then ["error at "++ ((showFromPosn . tokenPosn) $1) ++ ":cannot use 'break' out of loops!"]
                    else []
        ; $$.stateout = $$.statein
        ; $$.code = if (isJust (lookupEnv "break" $$.envloc))
                    then [(Rules (Goto ((((label . fromJust) (lookupEnv "break" $$.envloc))))))]
                    else []
    }

--  ========================
--  =======  FUND  =========
--  ========================
-- if $7.envin; se bad vuol dire che è già dichiarata, ma se la funzione viene
-- utilizzata correttamente nella "nuova" dichiarazione non vedo perchè deve 
-- dare errori nelle chiamate interne alla funzione stessa!
FuncD : CompoundType 'function' LIdent '(' ListParamF ')' BlockF 'end'
    { 
        $$.parsetree = AbsAuL.FnctDecl $1.parsetree $3.vlident $5.parsetree $7.parsetree
        ; $7.envloc = insertRetEnv $1.parsetree False (bypassEnvLoc $5.listparf)
        ; $7.envin = if (isOk (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))
                         then (mergeEnv (fromOk (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))
                                       $$.envin)
                         else (mergeEnv (mergeEnv 
                                            (fromOk (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn emptyEnv))
                                            $$.envloc) 
                                        $$.envin)
        ; $$.envout = if (isOk (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))
                         then (fromOk (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))
                         else $$.envloc
        ; $$.errs = (if (isBad (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))
                         then [(fromBad (insertFnctEnv $1.parsetree $3.vlident $5.listparf $3.posn $$.envloc))]
                         else []) ++ $7.errs ++
                    (if((getBaseComType $1.parsetree)== BasicType_Void && ( (getArrComType $1.parsetree) > 0 || (getPtrComType $1.parsetree) > 0))
                        then ["error at " ++((showFromPosn . tokenPosn) $2) ++": erroneus definition of function type. Maybe you "++
                              "would define it as Int, Float,...?"]
                        else [])
        ; $3.statein = $$.statein
        ; $7.statein = $3.stateout
        ; $7.nextLabel = $$.nextLabel
        ; $$.stateout = $7.stateout
        ; $$.code = [(LRules (argOpToString $3.addr) (Func (length $5.listparf))) ] ++ (paramToTac $5.listparf)  ++ $7.code
         
    }
ParamF : Modality BasicType LExp 
    { 
        $$.parsetree = AbsAuL.ParmDeclF $1.parsetree $2.parsetree $3.parsetree
        ; $$.posn = $3.posn
        ; $$.parname = (fromLIdent . getLIdentlexp) $3.parsetree
    }
ListParamF : {- empty -} 
    { 
        $$.parsetree = []
        ; $$.listparf = []
    }
    | ParamF 
    { 
        $$.parsetree = (:[]) $1.parsetree
        ; $$.listparf = [($1.parsetree,$1.posn,$1.parname)]
    }
    | ParamF ',' ListParamF 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree
        ; $$.listparf = (:) ($1.parsetree,$1.posn,$1.parname) $3.listparf
    }
Modality : {- empty -} 
    { 
        $$.parsetree = AbsAuL.Modality1 
    }
    | 'val' 
    { 
        $$.parsetree = AbsAuL.Modality_val
    }
    | 'const' 
    { 
        $$.parsetree = AbsAuL.Modality_const 
    }
    | 'res' 
    { 
        $$.parsetree = AbsAuL.Modality_res 
    }
    | 'valres' 
    { 
        $$.parsetree = AbsAuL.Modality_valres 
    }
    | 'name' 
    { 
        $$.parsetree = AbsAuL.Modality_name 
    }
--  ========================
--  =======  LEXP  =========
--  ========================
LExp : LIdent 
    { 
        $$.parsetree = AbsAuL.LExpS $1.vlident
        ; $1.envin = $$.envin
        ; $$.posn = $1.posn
        ; $$.errs = []
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.listDim = []
        ; $$.addr = $1.addr
        ; $$.code = $1.code
        
    }
    | '*' LExp 
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.LExpDR $2.parsetree 
        ; $$.listDim = []
        ; $$.posn = $2.posn
        ; $$.errs = $2.errs
        ; $2.statein = $$.statein
        ; $$.stateout = skipState $2.stateout 1 0
        ; $$.addr = $2.addr 
        ; $2.tipo = $$.tipo
        ; $$.code = [(Rules (AssignPointer (gentemp $$.stateout 0) (toTACType $2.tipo) $2.addr ))] ++ $2.code 
    }
    | LIdent ListDim
    { 
        $2.envin = $$.envin
        ; $1.envin = $$.envin
        ; $$.parsetree = AbsAuL.LExpA $1.vlident $2.parsetree
        ; $$.posn = $1.posn
        ; $$.errs = $2.errs
        ; $1.statein = $$.statein
        ; $2.statein = $1.stateout
        ; $$.stateout = $2.stateout
        ; $$.addr = $1.addr
        ; $$.listDim = $2.listDim    
        ; $$.code = $2.code 
        
    }

ListDim : Dim 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = (:[]) $1.parsetree 
        ; $$.errs = $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = $1.code
        ; $$.listDim = $1.listDim
        
    } 
    | Dim ListDim 
    { 
        $1.envin = $$.envin
        ; $2.envin = $$.envin
        ; $$.parsetree = (:) $1.parsetree $2.parsetree
        ; $$.errs = $1.errs ++ $2.errs
        ; $1.statein = $$.statein
        ; $2.statein = $1.stateout
        ; $$.stateout = $2.stateout
        ; $$.code = $1.code ++ $2.code
        ; $$.listDim = (:) $1.addr $2.listDim 
        
    }

Dim : '[' RExp ']' --VARA CHE GNOCCA STA COMPARAZIONE!!
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.Dims $2.parsetree
        ; $$.errs = if (op2CompType EqO $2.tipo (Base BasicType_Int)) == ErrT
                       then ["error at "++ ((showFromPosn . tokenPosn) $1) ++ ": type for arrays referencing need to be 'Int'!"]
                       else []
        ; $2.statein = $$.statein
        ; $$.stateout = $2.stateout
        ; $$.code = $2.code
        ; $$.addr = $2.addr
        ; $$.listDim = [$2.addr]
    }

--  ========================
--  =======  REXP  =========
--  ========================


RExp : RExp 'or' RExp1 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Or $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType OrO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for 'or' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool 
        ; $1.statein = $$.statein 
      	; $3.statein = $1.stateout
        ; $$.stateout = skipState $3.stateout 0 1 
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = genlabel $3.stateout 1
        ; $3.condTrue = $$.condTrue
        ; $3.condFalse = $$.condFalse
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (CondRelation $1.addr (relop IsEq (toTACType (higherType $1.tipo $3.tipo))) $3.addr (genlabel $$.statein 0)))] ++ $1.code ++ $3.code
    }
    | RExp1 'and' RExp2 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.And $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType AndO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for 'and' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool 
        ; $1.statein = $$.statein 
      	; $3.statein = $1.stateout
        ; $$.stateout = skipState $3.stateout 0 1 
        ; $1.condTrue = genlabel $3.stateout 1
        ; $2.condFalse = $$.condFalse
        ; $3.condTrue = $$.condTrue
        ; $3.condFalse = $$.condFalse
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (CondRelation $1.addr (relop IsEq (toTACType (higherType $1.tipo $3.tipo))) $3.addr (genlabel $$.statein 0)))] ++ $1.code ++ $3.code
    }
    | RExp1 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
RExp2 : 'not' RExp3 
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.Not $2.parsetree
        ; $$.errs = (if (not ((op1CompType NotO $2.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $1) ++ ": type need to be compatible in 'not' operations!"]) ++ $2.errs
        ; $$.tipo = Base BasicType_Bool
        ; $2.statein = $$.statein
        ; $$.stateout = $2.stateout 
        ; $2.condFalse = $$.condTrue
        ; $2.condTrue = $$.condFalse
        ; $$.addr = (gentemp $$.statein 0)       
        ; $$.code = [(Rules (AssgmUn (toTACType $$.tipo) $$.addr NotBool $2.addr))] ++ $2.code
    } 
    | RExp3 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
RExp3 : RExp5 '==' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Eq $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType EqO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '==' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool 
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateoutRelOpEqDif $1.tipo $3.tipo $1.code $3.code $$.condTrue $$.condFalse $1.addr $3.addr $3.stateout IsEq
    	; $1.condTrue  = genlabel $3.stateout 1
    	; $1.condFalse = genlabel $3.stateout 2
    	; $3.condTrue  = genlabel $3.stateout 4
    	; $3.condFalse = genlabel $3.stateout 5
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (CondRelation $1.addr (relop IsEq (toTACType (higherType $1.tipo $3.tipo))) $3.addr (genlabel $$.statein 1)))] ++ $1.code ++ $3.code
    }
    | RExp5 '~=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Neq $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType NeqO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '~=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool 
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateoutRelOpEqDif $1.tipo $3.tipo $1.code $3.code $$.condTrue $$.condFalse $1.addr $3.addr $3.stateout IsDiff
    	; $1.condTrue  = genlabel $3.stateout 1
    	; $1.condFalse = genlabel $3.stateout 2
    	; $3.condTrue  = genlabel $3.stateout 4
    	; $3.condFalse = genlabel $3.stateout 5
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (CondRelation $1.addr (relop IsDiff (toTACType (higherType $1.tipo $3.tipo))) $3.addr (genlabel $$.statein 1)))] ++ $1.code ++ $3.code
    }
    | RExp5 '<' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Lt $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType LtO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '<' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateRelOpDisEq  $1.tipo $3.tipo $1.code $3.code $$.condTrue $$.condFalse $1.addr $3.addr $3.stateout IsL
    	; $1.condTrue  = genlabel $3.stateout 1
    	; $1.condFalse = genlabel $3.stateout 2
    	; $3.condTrue  = genlabel $3.stateout 4
    	; $3.condFalse = genlabel $3.stateout 5
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (CondRelation $1.addr (relop IsL (toTACType (higherType $1.tipo $3.tipo))) $3.addr (genlabel $$.statein 1)))] ++ $1.code ++ $3.code
    }
    | RExp5 '<=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.LtE $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType LtEO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '<=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateRelOpDisEq  $1.tipo $3.tipo $1.code $3.code $$.condTrue $$.condFalse $1.addr $3.addr $3.stateout IsLEQ
    	; $1.condTrue  = genlabel $3.stateout 1
    	; $1.condFalse = genlabel $3.stateout 2
    	; $3.condTrue  = genlabel $3.stateout 4
    	; $3.condFalse = genlabel $3.stateout 5
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (CondRelation $1.addr (relop IsLEQ (toTACType (higherType $1.tipo $3.tipo))) $3.addr (genlabel $$.statein 1)))] ++ $1.code ++ $3.code
    }
    | RExp5 '>' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Gt $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType GtO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '>' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateRelOpDisEq  $1.tipo $3.tipo $1.code $3.code $$.condTrue $$.condFalse $1.addr $3.addr $3.stateout IsG
    	; $1.condTrue  = genlabel $3.stateout 1
    	; $1.condFalse = genlabel $3.stateout 2
    	; $3.condTrue  = genlabel $3.stateout 4
    	; $3.condFalse = genlabel $3.stateout 5
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (CondRelation $1.addr (relop IsG (toTACType (higherType $1.tipo $3.tipo))) $3.addr (genlabel $$.statein 1)))] ++ $1.code ++ $3.code
    }
    | RExp5 '>=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.GtE $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType GtEO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '>=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = Base BasicType_Bool
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateRelOpDisEq  $1.tipo $3.tipo $1.code $3.code $$.condTrue $$.condFalse $1.addr $3.addr $3.stateout IsGEQ
    	; $1.condTrue  = genlabel $3.stateout 1
    	; $1.condFalse = genlabel $3.stateout 2
    	; $3.condTrue  = genlabel $3.stateout 4
    	; $3.condFalse = genlabel $3.stateout 5
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (CondRelation $1.addr (relop IsGEQ (toTACType (higherType $1.tipo $3.tipo))) $3.addr (genlabel $$.statein 1)))] ++ $1.code ++ $3.code
    }                        
    | RExp4 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
RExp6 : RExp6 '+' RExp7 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Add $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType AddO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": '+' arguments' types need to be Int, Float or Char!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((op2CompType AddO $1.tipo $3.tipo) == ErrT) 
                         then (Base BasicType_Float)
                         else (op2CompType AddO $1.tipo $3.tipo) )  
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateoutBinOp $1.tipo $3.tipo $1.addr $3.addr $3.stateout TAC.Add 
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (AssgmBin (toTACType $$.tipo) $$.addr $1.addr (binop TAC.Add (toTACType $$.tipo)) $3.addr))] ++ $1.code ++ $3.code
    
    }
    | RExp6 '-' RExp7 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Sub $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType SubO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": '-' arguments' types need to be Int, Float or Char!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((op2CompType SubO $1.tipo $3.tipo) == ErrT) 
                         then (Base BasicType_Float)
                         else (op2CompType SubO $1.tipo $3.tipo) )   
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateoutBinOp $1.tipo $3.tipo $1.addr $3.addr $3.stateout TAC.Sub 
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (AssgmBin (toTACType $$.tipo) $$.addr $1.addr (binop TAC.Sub (toTACType $$.tipo)) $3.addr))] ++ $1.code ++ $3.code
    
    }
    | RExp7 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
RExp7 : RExp7 '*' RExp8 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Mul $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType MulO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": '*' arguments' types need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((op2CompType MulO $1.tipo $3.tipo) == ErrT) 
                         then (Base BasicType_Float)
                         else (op2CompType MulO $1.tipo $3.tipo) )  
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateoutBinOp $1.tipo $3.tipo $1.addr $3.addr $3.stateout TAC.Mul
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (AssgmBin (toTACType $$.tipo) $$.addr $1.addr (binop TAC.Mul (toTACType $$.tipo)) $3.addr))] ++ $1.code ++ $3.code
    
    }
    | RExp7 '/' RExp8 
    {
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Div $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType DivO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": '/' arguments' types need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((op2CompType DivO $1.tipo $3.tipo) == ErrT) 
                         then (Base BasicType_Float)
                         else (op2CompType DivO $1.tipo $3.tipo) )
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateoutBinOp $1.tipo $3.tipo $1.addr $3.addr $3.stateout TAC.Div
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (AssgmBin (toTACType $$.tipo) $$.addr $1.addr (binop TAC.Div (toTACType $$.tipo)) $3.addr))] ++ $1.code ++ $3.code
    
    }
    | RExp7 '%' RExp8 
    {   
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Rem $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType RemO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": '%' arguments' types need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = (Base BasicType_Int) 
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateoutBinOp $1.tipo $3.tipo $1.addr $3.addr $3.stateout TAC.Mod 
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (AssgmBin (toTACType $$.tipo) $$.addr $1.addr (binop TAC.Mod (toTACType $$.tipo)) $3.addr))] ++ $1.code ++ $3.code
    
    }
    | RExp8 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
RExp8 : RExp9 '^' RExp8 
    {   
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.Pow $1.parsetree $3.parsetree
        ; $$.errs = (if (not ((op2CompType PowO $1.tipo $3.tipo) == ErrT))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.tipo = ( if ((op2CompType PowO $1.tipo $3.tipo) == ErrT) 
                         then (Base BasicType_Float)
                         else (op2CompType PowO $1.tipo $3.tipo) )
        ; $1.statein = $$.statein
      	; $3.statein = $1.stateout
        ; $$.stateout = stateoutBinOp $1.tipo $3.tipo $1.addr $3.addr $3.stateout TAC.Exp 
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (AssgmBin (toTACType $$.tipo) $$.addr $1.addr (binop TAC.Exp (toTACType $$.tipo)) $3.addr))] ++ $1.code ++ $3.code
    
    } 
    | RExp9 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
RExp9 : '-' RExp10
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.Neg $2.parsetree
        ; $2.statein = $$.statein
        ; $$.stateout = stateoutUnOp $2.tipo $2.addr $2.stateout Negation
        ; $$.errs = (if (not ((op1CompType NeqO $2.tipo) == ErrT))
                         then []
                         else ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": in negation operator type need to be 'Int' or 'Float'!"]   ) ++ $2.errs
        ; $$.tipo = if (op1CompType NegO $2.tipo) == ErrT
                         then (Base BasicType_Float)
                         else (op1CompType NeqO $2.tipo)
        ; $$.addr = (gentemp $$.statein 0)
        ; $$.code = [(Rules (AssgmUn (toTACType $2.tipo) $$.addr TAC.NotBool $2.addr))] ++ $2.code
    } 
    | RExp10 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
RExp10 : Func
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsAuL.FCall $1.parsetree
        ; $$.tipo = if (($1.tipo == (Base BasicType_Void)) || $1.tipo == ErrT)
                        then ErrT
                        else $1.tipo
        ; $$.errs = (if (($1.tipo == (Base BasicType_Void)) || $1.tipo == ErrT)
                        then ["error in RExp10: cannot use a 'Void' function in expression!"]
                        else []) ++ $1.errs
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.addr = $1.addr 
        ; $$.code = $1.code
    }
    | RExp10 '..' RExp11
    --TODO: assegnamento funzione
    {
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsAuL.FStrCnt $1.parsetree $3.parsetree
        ; $$.tipo = op2CompType ConcatO $1.tipo $3.tipo
        ; $$.errs = (if (op2CompType ConcatO $1.tipo $3.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $2) ++": '..' need to have 'Char'(s) or 'String'(s) as arguments!"]
                        else []) ++ $1.errs ++ $3.errs 
        ; $1.statein = $$.statein
        ; $3.statein = $1.stateoutBinOp
        ; $$.stateout = $3.stateout
        ; $$.code = $1.code ++ [(Rules(ProcCall (InternalFunc "concat") 1))] ++ $3.code  
    }
    | '#' RExp11
    --TODO: assegnamento funzione
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsAuL.FLen $2.parsetree
        ; $$.tipo = op1CompType SizeO $2.tipo
        ; $$.errs = (if (op1CompType SizeO $2.tipo) == ErrT
                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": '#' need to have Arrays or Pointer as argument!"]
                        else []) ++ $2.errs 
        ; $2.statein = $$.statein
        ; $$.stateout = $2.stateout
        ; $$.addr = $2.addr
        ; $$.code = [(Rules(ProcCall (InternalFunc "lenght") 1))] ++ $2.code  
    }
    | RExp11 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }

RExp11 : Integer --TODO: controlla tipi LEXP e &LEXP: controlla che arr non possa essere abbassato di grado con *
    { 
        $$.parsetree = AbsAuL.ValInt $1.vint
        ; $$.tipo = Base BasicType_Int
        ; $$.envout = $$.envin
        ; $$.addr = $1.addr
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.errs = []
        ; $$.code = []
    }
    | LExp --possibile mismatch parentesi
    { 
        $$.parsetree = AbsAuL.ValVariable $1.parsetree
        ; $1.envin = $$.envin 
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                        then (if (isFnctEnv (fromJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin)))
                                then ErrT
                                else (downCmpType (getPtrLev $1.parsetree) (getArrLev $1.parsetree)
                                        ((fst . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))))
                        else ErrT )
        ; $$.errs = (if (isNothing (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                        then ["error: reference to " ++ ((fromLIdent . getLIdentlexp) $1.parsetree) ++ " at line " ++
                                (showFromPosn $1.posn) ++ " is invalid (maybe not declared variable?)"]
                        else ( if (not (isFnctEnv (fromJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))))
                                   then (if ((downCmpType (getPtrLev $1.parsetree) (getArrLev $1.parsetree)
                                              ((fst . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))) == ErrT)
                                            then ["error at "++ (showFromPosn $1.posn) ++": invalid dereferencing (maybe too much?) referring to '"++ 
                                                    ((fromLIdent . getLIdentlexp) $1.parsetree) ++"'"]
                                            else []) 
                                   else ["error at "++ (showFromPosn $1.posn) ++": cannot use a function as a variable!"])
                    ) ++ $1.errs ++
                     (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                            then if ((snd . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin) == Modality_res)
                                    then ["error at "++ (showFromPosn $1.posn) ++": cannot refer this variable in modality 'res'!"]
                                    else []
                            else [])
        ; $$.addr = $1.addr
        ; $$.code = if (not $ null $1.listDim) then [(Rules (ArrayEl (toTACType $$.tipo) (gentemp $$.stateout 0) $$.addr))] ++
                                                    listDimToTac $1.listDim  
                                               else []
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
    }
    | '&' LExp 
    { 
        $$.parsetree = AbsAuL.ValRef $2.parsetree
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                        then (if (not (isFnctEnv (fromJust (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))))
                                 then (addPtrT ( downCmpType (getPtrLev $2.parsetree) (getArrLev $2.parsetree)
                                        ((fst . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))))
                                 else ErrT)
                        else ErrT )
        ; $$.errs = (if (isNothing (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                        then ["error: reference to " ++ ((fromLIdent . getLIdentlexp) $2.parsetree) ++ " at line " ++
                                (showFromPosn $2.posn) ++ "is invalid (maybe not declared variable?)"]
                        else (if (not (isFnctEnv (fromJust (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))))
                                then (if ((addPtrT ( downCmpType (getPtrLev $2.parsetree) (getArrLev $2.parsetree)
                                                ((fst . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin)))) == ErrT)
                                        then ["error at "++ ((showFromPosn . tokenPosn) $1) ++": too many dereferencing refering to '"
                                                ++ ((fromLIdent . getLIdentlexp) $2.parsetree) ++"'"]
                                        else [] )
                                else ["error at "++ (showFromPosn $2.posn) ++": cannot use a function as a variable!"])) ++ $2.errs ++
                     (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                            then if ((snd . getType . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin) == Modality_res)
                                    then ["error at "++ (showFromPosn $2.posn) ++": cannot refer this variable in modality 'res'!"]
                                    else []
                            else [])
        ; $2.statein = $$.statein
        ; $$.stateout = $2.stateout 
        ; $$.code =  [(Rules (AssignAddress (gentemp $$.stateout 0) (toTACType $$.tipo) $2.addr))]  
        
    }
    | Double --modded
    { 
        $$.parsetree = AbsAuL.ValDouble $1.vdbl
        ; $$.tipo = Base BasicType_Float
        ; $$.errs = []
        ; $$.addr = $1.addr
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = []
    }
    | String --modded
    { 
        $$.parsetree = AbsAuL.ValString $1.vstr
        ; $$.tipo = Base BasicType_String
        ; $$.errs = []
        ; $$.addr = $1.addr
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = []
    }
    | Char --modded
    { 
        $$.parsetree = AbsAuL.ValChar $1.vchr
        ; $$.tipo = Base BasicType_Char
        ; $$.errs = []
        ; $$.addr = $1.addr
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = []
    }
    | Boolean 
    { 
        $$.parsetree = AbsAuL.ValBoolean $1.parsetree
        ; $$.tipo = Base BasicType_Bool
        ; $$.errs = []
        ; $$.addr = $1.addr
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = []
    }
    | PtrVoid 
    { 
        $$.parsetree = AbsAuL.ValPtr $1.parsetree
        ; $$.tipo = Base BasicType_Void
        ; $$.errs = []
        ; $$.addr = $1.addr
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $$.code = []
    }
    | RExp12 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree 
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }

RExp1 : RExp2 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
RExp4 : RExp5 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
RExp5 : RExp6 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo 
        ; $1.statein = $$.statein
        ; $$.stateout = $1.stateout
        ; $1.condTrue = $$.condTrue
        ; $1.condFalse = $$.condFalse
        ; $$.addr = $1.addr
        ; $$.code = $1.code
    }
RExp12 : '(' RExp ')' 
    { 
        $2.envin = $$.envin
        ; $$.parsetree = $2.parsetree
        ; $$.errs = $2.errs
        ; $$.tipo = $2.tipo 
        ; $2.statein = $$.statein
        ; $$.stateout = $2.stateout
        ; $2.condTrue = $$.condTrue
        ; $2.condFalse = $$.condFalse
        ; $$.addr = $2.addr
        ; $$.code = $2.code
    }

{

data Result = Result Program [TAC] EnvT [String]  deriving (Eq, Show)

controlArrTipo :: CmpType -> Array -> Token -> [String]
controlArrTipo ts arr tok
    | (isArrT ts) && (not (isPtrT ts)) = if (checkTypeInit (getBaseType ts) arr)
                                            then if (sameLenChk (getArrTLev ts) arr)
                                                    then []
                                                    else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                                          ": array initialization hasn't same "++
                                                          "deferencing level of type definition (" ++ 
                                                          (show (getArrTLev ts)) ++")!"]
                                            else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                                  ": array initialization isn't of the same type of " ++
                                                  "variable type ('"++ (showCmpType (Base (getBaseType ts))) ++"')!"]
    | (isArrT ts) && (isPtrT ts) = if (checkTypeInit BasicType_Void arr)
                                      then if (sameLenChk (getArrTLev ts) arr)
                                              then []
                                              else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                                    ": array initialization hasn't same "++
                                                    "deferencing level of type definition (" ++ 
                                                    (show (getArrTLev ts)) ++")!"]
                                      else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                            ": array initialization isn't of the same type of " ++
                                            "variable type ('"++ (showCmpType  ts) ++"')!"]
    | (not (isArrT ts)) && (isPtrT ts) = let nts = makeCmpType  0 (getPtrTLev ts) (getBaseType ts)
                                         in if (checkTypeInit (getBaseType nts) arr)
                                                then if (sameLenChk (getArrTLev nts) arr)
                                                        then []
                                                        else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                                              ": array initialization hasn't same "++
                                                              "deferencing level of type definition (" ++ 
                                                              (show (getArrTLev ts)) ++")!"]
                                                else ["error at "++ ((showFromPosn . tokenPosn) tok) ++ 
                                                      ": array initialization isn't of the same type of " ++
                                                      "variable type ('"++ (showCmpType (Base (getBaseType ts))) ++"')!"]

controlFnctTipo' :: [CmpType] -> [CmpType] -> [String]
controlFnctTipo' ps rexps = foldr (\(te,tr,pn) xs -> (cmpType te tr pn) ++ xs) [] (zip3 ps rexps [1..])
    where cmpType te tr pn = if (compCmpType te tr) == ErrT
                                then ["    param "++ (show pn)++": expected type was '" ++ 
                                     (showCmpType te) ++ "' but recieved type '" ++ 
                                     (showCmpType tr) ++ "'"]
                                else []

controlFnctTipo ps rexps posn = let errs = controlFnctTipo' ps rexps
                                 in if ((length ps) /= (length rexps))
                                     then ["error at "++(showFromPosn posn)++
                                           ": the parameters passed to function are insufficient!"]
                                     else if ((length errs) == 0)
                                            then []
                                            else ["error at "++(showFromPosn posn)++":"]++errs

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

