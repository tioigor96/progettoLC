-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParBnfc where
import AbsBnfc
import LexBnfc
import ErrM

}

%name pProgram Program
%name pListPGlobl ListPGlobl
%name pPGlobl PGlobl
%name pBlock Block
%name pListStm ListStm
%name pBasicType BasicType
%name pBoolean Boolean
%name pPtrVoid PtrVoid
%name pStm Stm
%name pEBlk EBlk
%name pDecl Decl
%name pVarInit VarInit
%name pLocal Local
%name pAss Ass
%name pFunc Func
%name pFuncWrite FuncWrite
%name pFuncRead FuncRead
%name pWhile While
%name pRepeat Repeat
%name pFor For
%name pIncrement Increment
%name pIf If
%name pElse Else
%name pElseIf ElseIf
%name pListElseIf ListElseIf
%name pReturn Return
%name pRValue RValue
%name pBreak Break
%name pListRExp ListRExp
%name pFuncD FuncD
%name pParamF ParamF
%name pListParamF ListParamF
%name pModality Modality
%name pLExp LExp
%name pListDim ListDim
%name pDim Dim
%name pRExp RExp
%name pRExp2 RExp2
%name pRExp3 RExp3
%name pRExp6 RExp6
%name pRExp7 RExp7
%name pRExp8 RExp8
%name pRExp9 RExp9
%name pRExp10 RExp10
%name pRExp11 RExp11
%name pRExp12 RExp12
%name pArray Array
%name pVType VType
%name pListVType ListVType
%name pRExp1 RExp1
%name pRExp4 RExp4
%name pRExp5 RExp5
%name pRExp13 RExp13
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '..' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '<=' { PT _ (TS _ 14) }
  '=' { PT _ (TS _ 15) }
  '==' { PT _ (TS _ 16) }
  '>' { PT _ (TS _ 17) }
  '>=' { PT _ (TS _ 18) }
  'Bool' { PT _ (TS _ 19) }
  'Char' { PT _ (TS _ 20) }
  'Float' { PT _ (TS _ 21) }
  'Int' { PT _ (TS _ 22) }
  'String' { PT _ (TS _ 23) }
  'Void' { PT _ (TS _ 24) }
  '[' { PT _ (TS _ 25) }
  ']' { PT _ (TS _ 26) }
  '^' { PT _ (TS _ 27) }
  'and' { PT _ (TS _ 28) }
  'break' { PT _ (TS _ 29) }
  'const' { PT _ (TS _ 30) }
  'do' { PT _ (TS _ 31) }
  'else' { PT _ (TS _ 32) }
  'elseif' { PT _ (TS _ 33) }
  'end' { PT _ (TS _ 34) }
  'false' { PT _ (TS _ 35) }
  'for' { PT _ (TS _ 36) }
  'function' { PT _ (TS _ 37) }
  'if' { PT _ (TS _ 38) }
  'in' { PT _ (TS _ 39) }
  'local' { PT _ (TS _ 40) }
  'name' { PT _ (TS _ 41) }
  'nil' { PT _ (TS _ 42) }
  'not' { PT _ (TS _ 43) }
  'or' { PT _ (TS _ 44) }
  'readChar' { PT _ (TS _ 45) }
  'readFloat' { PT _ (TS _ 46) }
  'readInt' { PT _ (TS _ 47) }
  'readString' { PT _ (TS _ 48) }
  'ref' { PT _ (TS _ 49) }
  'repeat' { PT _ (TS _ 50) }
  'res' { PT _ (TS _ 51) }
  'return' { PT _ (TS _ 52) }
  'then' { PT _ (TS _ 53) }
  'true' { PT _ (TS _ 54) }
  'until' { PT _ (TS _ 55) }
  'val' { PT _ (TS _ 56) }
  'valres' { PT _ (TS _ 57) }
  'while' { PT _ (TS _ 58) }
  'writeChar' { PT _ (TS _ 59) }
  'writeFloat' { PT _ (TS _ 60) }
  'writeInt' { PT _ (TS _ 61) }
  'writeString' { PT _ (TS _ 62) }
  '{' { PT _ (TS _ 63) }
  '}' { PT _ (TS _ 64) }
  '~=' { PT _ (TS _ 65) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_LIdent { PT _ (T_LIdent $$) }

-- tipi per gli attributi di $$
-- %attributetype {AttrT}
-- %attribute rexp { RExp }         -- 14 prod
-- %attribute lexp { LExp }         -- 1 prod
-- %attribute lRExp { [RExp] }      -- 1 prod
-- %attribute program { Program }   -- 1 prod
-- %attribute lPGlob { [PGlob] }    -- 1 prod
-- %attribute pglobl { PGlob }      -- 1 prod
-- e tutti gli altri...................DC

%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
String  :: { String }  : L_quoted {  $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
LIdent    :: { LIdent} : L_LIdent { LIdent ($1)}

Program :: { Program }
Program : ListPGlobl 
        { 
            AbsBnfc.Prog $1 
        }
                     
                     
ListPGlobl :: { [PGlobl] }
ListPGlobl : 
                PGlobl 
        { 
            (:[]) $1 
        }
                         
           | PGlobl ListPGlobl 
        { 
            (:) $1 $2 
        }
                        
PGlobl :: { PGlobl }
PGlobl : Stm 
        { 
            AbsBnfc.ProgGlobB $1 
        }
       | FuncD 
        { 
            AbsBnfc.ProgGlobF $1 
        }


Block :: { Block }
Block : ListStm 
        { 
        AbsBnfc.Blk $1 
        }


ListStm :: { [Stm] }
ListStm : Stm 
        { 
            (:[]) $1
        } 
       | Stm ListStm 
        { 
            (:) $1 $2 
        }


BasicType :: { BasicType }
BasicType : 'Bool'
        { 
        AbsBnfc.BasicType_Bool
        }
          | 'Char' 
        { 
            AbsBnfc.BasicType_Char 
        }
          | 'Float' 
        { 
            AbsBnfc.BasicType_Float
        }
          | 'Int' 
        { 
            AbsBnfc.BasicType_Int 
        }
          | 'String' 
        { 
            AbsBnfc.BasicType_String
        }
          | 'Void' 
        { 
            AbsBnfc.BasicType_Void
        }


Boolean :: { Boolean }
Boolean : 'true' 
        { 
            AbsBnfc.Boolean_true
        }
        | 'false' 
        { 
            AbsBnfc.Boolean_false 
        }


PtrVoid :: { PtrVoid }
PtrVoid : 'nil' 
        { 
            AbsBnfc.PtrType
        }


Stm :: { Stm }
Stm : Decl ';' 
        { 
            AbsBnfc.SDecl $1 
        }
    | Local ';' 
        { 
            AbsBnfc.SLocal $1 
        }
    | Ass ';' 
        { 
            AbsBnfc.SAss $1 
        }
    | While 
        { 
            AbsBnfc.SWhile $1 
        }
    | Repeat ';' 
        { 
            AbsBnfc.SRepeat $1 
        }
    | For 
        { 
            AbsBnfc.SFor $1 
        }
    | If 
        { 
            AbsBnfc.SIf $1 
        }
    | RExp ';' 
        { 
            AbsBnfc.SRExp $1 
        }
    | EBlk 
        { 
            AbsBnfc.SEBlk $1 
        }
    | Return ';' 
        { 
            AbsBnfc.SReturn $1 
        }
    | Break ';' 
        { 
            AbsBnfc.SBreak $1 
        }


EBlk :: { EBlk }
EBlk : 'do' Block 'end' 
        { 
            AbsBnfc.EBlkS $2 
        }


Decl :: { Decl }
Decl : BasicType LExp VarInit 
        { 
            AbsBnfc.DeclSP $1 $2 $3 
        }


VarInit :: { VarInit }
VarInit : {- empty -} 
        { 
            AbsBnfc.VarINil 
        }
        | '=' RExp 
        { 
            AbsBnfc.VarExp $2 
        }


Local :: { Local }
Local : 'local' Decl 
        { 
            AbsBnfc.DeclLocal $2 
        }


Ass :: { Ass }
Ass : LExp '=' RExp 
        { 
            AbsBnfc.AssD $1 $3 
        }


Func :: { Func }
Func : FuncWrite 
        { 
            AbsBnfc.FuncBW $1 
        }
     | FuncRead 
        { 
            AbsBnfc.FuncBR $1 
        }
     | LIdent '(' ListRExp ')' 
        { 
            AbsBnfc.FnctCall $1 $3 
        }


FuncWrite :: { FuncWrite }
FuncWrite : 'writeInt' '(' RExp ')' 
        { 
        AbsBnfc.WriteI $3 
        }
          | 'writeFloat' '(' RExp ')' 
        { 
            AbsBnfc.WriteF $3 
        }
          | 'writeChar' '(' RExp ')' 
        { 
            AbsBnfc.WriteC $3 
        }
          | 'writeString' '(' RExp ')' 
        { 
            AbsBnfc.WriteS $3 
        }


FuncRead :: { FuncRead }
FuncRead : 'readInt' '(' ')' 
        { 
            AbsBnfc.ReadI 
        }
         | 'readFloat' '(' ')' 
        { 
            AbsBnfc.ReadF 
        }
         | 'readChar' '(' ')' 
        { 
            AbsBnfc.ReadC 
        }
         | 'readString' '(' ')' 
        { 
            AbsBnfc.ReadS 
        }


While :: { While }
While : 'while' RExp 'do' Block 'end' 
        { 
            AbsBnfc.LoopW $2 $4 
        }


Repeat :: { Repeat }
Repeat : 'repeat' Block 'until' RExp 
        { 
            AbsBnfc.LoopR $2 $4 
        }


For :: { For }
For : 'for' LIdent '=' RExp ',' RExp Increment 'do' Block 'end' 
        { 
            AbsBnfc.LoopF $2 $4 $6 $7 $9 
        }
    | 'for' LIdent 'in' LIdent 'do' Block 'end' 
        { 
            AbsBnfc.LoopFE $2 $4 $6 
        }


Increment :: { Increment }
Increment : {- empty -} 
        { 
            AbsBnfc.FInc (ValInt 1) -- assumiamo che sia 1, appunto 
        }
          | ',' RExp 
        { 
            AbsBnfc.FInc $2
        }


If :: { If }
If : 'if' RExp 'then' Block ListElseIf Else 'end' 
        { 
            AbsBnfc.IfM $2 $4 (reverse $5) $6 
        }


Else :: { Else }
Else : 'else' Block 
        { 
            AbsBnfc.ElseS $2 
        }
     | {- empty -} 
        { 
            AbsBnfc.ElseE 
        }


ElseIf :: { ElseIf }
ElseIf : 'elseif' RExp 'then' Block 
        { 
            AbsBnfc.ElseIfD $2 $4 
        }


ListElseIf :: { [ElseIf] }
ListElseIf : {- empty -} 
        { 
            [] 
        }
           | ListElseIf ElseIf 
        { 
            flip (:) $1 $2 
        }


Return :: { Return }
Return : 'return' RValue 
        { 
            AbsBnfc.JumpR $2 
        }


RValue :: { RValue }
RValue : {- empty -} 
        { 
            AbsBnfc.JumpRE 
        }
       | RExp 
        { 
            AbsBnfc.JumpRV $1 
        }


Break :: { Break }
Break : 'break' 
        { 
            AbsBnfc.JumpB 
        }


ListRExp :: { [RExp] }
ListRExp : {- empty -} 
        { 
            [] 
        }
         | RExp 
        { 
            (:[]) $1 
        }
         | RExp ',' ListRExp 
        { 
            (:) $1 $3 
        }


FuncD :: { FuncD }
FuncD : BasicType 'function' LIdent '(' ListParamF ')' Block 'end' 
        { 
            AbsBnfc.FnctDecl $1 $3 $5 $7 
        }


ParamF :: { ParamF }
ParamF : Modality BasicType LExp 
        { 
            AbsBnfc.ParmDeclF $1 $2 $3 
        }


ListParamF :: { [ParamF] }
ListParamF : {- empty -} 
        { 
        [] 
        }
           | ParamF 
        { 
        (:[]) $1 
        }
           | ParamF ',' ListParamF 
        { 
            (:) $1 $3 
        }


Modality :: { Modality }
Modality : {- empty -} { AbsBnfc.Modality1 }
         | 'val' { AbsBnfc.Modality_val }
         | 'ref' { AbsBnfc.Modality_ref }
         | 'const' { AbsBnfc.Modality_const }
         | 'res' { AbsBnfc.Modality_res }
         | 'valres' { AbsBnfc.Modality_valres }
         | 'name' { AbsBnfc.Modality_name }


LExp :: { LExp }
LExp : LIdent { AbsBnfc.LExpS $1 }
     | '*' LExp { AbsBnfc.LExpDR $2 }
     | LIdent ListDim { AbsBnfc.LExpA $1 $2 }


ListDim :: { [Dim] }
ListDim : Dim 
        { 
            (:[]) $1 
        }
         | Dim ListDim 
        { 
            (:) $1 $2 
        }


Dim :: { Dim }
Dim : '[' Integer ']' 
        { 
            AbsBnfc.Dims $2 
        }


RExp :: { RExp }
RExp : RExp 'or' RExp1 
        { 
            AbsBnfc.Or $1 $3 
        }
     | RExp1 'and' RExp2 
        { 
            AbsBnfc.And $1 $3 
        }
     | RExp1 
        { 
            $1 
        }


RExp2 :: { RExp }
RExp2 : 'not' RExp3 
        { 
            AbsBnfc.Not $2 
        } 
        | RExp3 
        { 
            $1 
        }


RExp3 :: { RExp }
RExp3 : RExp3 '==' RExp5 
        { 
            AbsBnfc.Eq $1 $3 
        }
      | RExp3 '~=' RExp5 
        { 
            AbsBnfc.Neq $1 $3 
        }
      | RExp3 '<' RExp5 
        { 
            AbsBnfc.Lt $1 $3 
        }
      | RExp3 '<=' RExp5 
        { 
            AbsBnfc.LtE $1 $3 
        }
      | RExp3 '>' RExp5 
        { 
            AbsBnfc.Gt $1 $3 
        }
      | RExp3 '>=' RExp5 
        { 
            AbsBnfc.GtE $1 $3 
        }
      | RExp4 { $1 }


RExp6 :: { RExp }
RExp6 : RExp6 '+' RExp7 
        { 
            AbsBnfc.Add $1 $3 
        }
      | RExp6 '-' RExp7 
        { 
            AbsBnfc.Sub $1 $3 
        }
      | RExp7 
        { 
            $1 
        }


RExp7 :: { RExp }
RExp7 : RExp7 '*' RExp8 
        { 
            AbsBnfc.Mul $1 $3 
        }
      | RExp7 '/' RExp8 
        { 
            AbsBnfc.Div $1 $3 
        }
      | RExp7 '%' RExp8 
        { 
            AbsBnfc.Rem $1 $3 
        }
      | RExp8 
        { 
            $1 
        }


RExp8 :: { RExp }
RExp8 : RExp9 '^' RExp8 
        { 
            AbsBnfc.Pow $1 $3 
        } 
      | RExp9 
        { 
            $1 
        }


RExp9 :: { RExp }
RExp9 : '-' RExp10 
        { 
            AbsBnfc.Neg $2 
        } 
      | RExp10 
        { 
            $1 
        }


RExp10 :: { RExp }
RExp10 : Func 
        { 
            AbsBnfc.FCall $1 
        }
       | RExp10 '..' RExp11 
        { 
            AbsBnfc.FStrCnt $1 $3 
        }
       | '#' RExp11 
        { 
            AbsBnfc.FLen $2 
        }
       | RExp11 
        { 
            $1 
        }


RExp11 :: { RExp }
RExp11 : Integer 
        { 
            AbsBnfc.ValInt $1 
        }
       | LExp 
        { 
            AbsBnfc.ValVariable $1 
        }
       | '&' LExp 
        { 
            AbsBnfc.ValRef $2 
        }
       | Double 
        { 
            AbsBnfc.ValDouble $1 
        }
       | String 
        { 
            AbsBnfc.ValString $1 
        }
       | Char 
        { 
            AbsBnfc.ValChar $1 
        }
       | Boolean 
        { 
            AbsBnfc.ValBoolean $1 
        }
       | PtrVoid 
        { 
            AbsBnfc.ValPtr $1 
        }
       | RExp12 
        { 
            $1 
        }


RExp12 :: { RExp }
RExp12 : '{' Array '}' 
        { 
            AbsBnfc.ValMArr $2 
        } 
        | RExp13 
        { 
            $1 
        }


Array :: { Array }
Array : '{' Array '}' ',' Array 
        { 
            AbsBnfc.ArrayV0 $2 $5 
        }
      | '{' Array '}' 
        { 
            AbsBnfc.ArrayV1 $2 
        }
      | ListVType 
        { 
            AbsBnfc.ArrayV2 $1 
        }


VType :: { VType }      --una dummy qui?
VType : Boolean { AbsBnfc.VTypeBoolean $1 }
      | Char { AbsBnfc.VTypeChar $1 }
      | Double { AbsBnfc.VTypeDouble $1 }
      | Integer { AbsBnfc.VTypeInteger $1 }
      | String { AbsBnfc.VTypeString $1 }
      | PtrVoid { AbsBnfc.VTypePtrVoid $1 }
      | {- empty -} { AbsBnfc.VType1 }


ListVType :: { [VType] }
ListVType : VType 
        { 
            (:[]) $1 
        } 
        | VType ',' ListVType 
        { 
            (:) $1 $3 
        }


RExp1 :: { RExp }
RExp1 : RExp2 
        { 
            $1 
        }


RExp4 :: { RExp }
RExp4 : RExp5 
        { 
            $1 
        }


RExp5 :: { RExp }
RExp5 : RExp6 
        { 
            $1 
        }


RExp13 :: { RExp }
RExp13 : '(' RExp ')' 
        { 
            $2 
        }


{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

