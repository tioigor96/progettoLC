-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParBnfc where
import AbsBnfc
import LexBnfc
import ErrM

}

%name pProgram Program
%name pListPGlobl ListPGlobl
%name pPGlobl PGlobl
%name pBlock Block
%name pListStm ListStm
%name pBasicType BasicType
%name pBoolean Boolean
%name pPtrVoid PtrVoid
%name pStm Stm
%name pEBlk EBlk
%name pDecl Decl
%name pVarInit VarInit
%name pLocal Local
%name pAss Ass
%name pFunc Func
%name pFuncWrite FuncWrite
%name pFuncRead FuncRead
%name pWhile While
%name pRepeat Repeat
%name pFor For
%name pIncrement Increment
%name pIf If
%name pElse Else
%name pElseIf ElseIf
%name pListElseIf ListElseIf
%name pReturn Return
%name pRValue RValue
%name pBreak Break
%name pListRExp ListRExp
%name pFuncD FuncD
%name pParamF ParamF
%name pListParamF ListParamF
%name pModality Modality
%name pLExp LExp
%name pListDim ListDim
%name pDim Dim
%name pRExp RExp
%name pRExp2 RExp2
%name pRExp3 RExp3
%name pRExp6 RExp6
%name pRExp7 RExp7
%name pRExp8 RExp8
%name pRExp9 RExp9
%name pRExp10 RExp10
%name pRExp11 RExp11
%name pRExp12 RExp12
%name pArray Array
%name pVType VType
%name pListVType ListVType
%name pRExp1 RExp1
%name pRExp4 RExp4
%name pRExp5 RExp5
%name pRExp13 RExp13
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '..' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '<=' { PT _ (TS _ 14) }
  '=' { PT _ (TS _ 15) }
  '==' { PT _ (TS _ 16) }
  '>' { PT _ (TS _ 17) }
  '>=' { PT _ (TS _ 18) }
  'Bool' { PT _ (TS _ 19) }
  'Char' { PT _ (TS _ 20) }
  'Float' { PT _ (TS _ 21) }
  'Int' { PT _ (TS _ 22) }
  'String' { PT _ (TS _ 23) }
  'Void' { PT _ (TS _ 24) }
  '[' { PT _ (TS _ 25) }
  ']' { PT _ (TS _ 26) }
  '^' { PT _ (TS _ 27) }
  'and' { PT _ (TS _ 28) }
  'break' { PT _ (TS _ 29) }
  'const' { PT _ (TS _ 30) }
  'do' { PT _ (TS _ 31) }
  'else' { PT _ (TS _ 32) }
  'elseif' { PT _ (TS _ 33) }
  'end' { PT _ (TS _ 34) }
  'false' { PT _ (TS _ 35) }
  'for' { PT _ (TS _ 36) }
  'function' { PT _ (TS _ 37) }
  'if' { PT _ (TS _ 38) }
  'in' { PT _ (TS _ 39) }
  'local' { PT _ (TS _ 40) }
  'name' { PT _ (TS _ 41) }
  'nil' { PT _ (TS _ 42) }
  'not' { PT _ (TS _ 43) }
  'or' { PT _ (TS _ 44) }
  'readChar' { PT _ (TS _ 45) }
  'readFloat' { PT _ (TS _ 46) }
  'readInt' { PT _ (TS _ 47) }
  'readString' { PT _ (TS _ 48) }
  'ref' { PT _ (TS _ 49) }
  'repeat' { PT _ (TS _ 50) }
  'res' { PT _ (TS _ 51) }
  'return' { PT _ (TS _ 52) }
  'then' { PT _ (TS _ 53) }
  'true' { PT _ (TS _ 54) }
  'until' { PT _ (TS _ 55) }
  'val' { PT _ (TS _ 56) }
  'valres' { PT _ (TS _ 57) }
  'while' { PT _ (TS _ 58) }
  'writeChar' { PT _ (TS _ 59) }
  'writeFloat' { PT _ (TS _ 60) }
  'writeInt' { PT _ (TS _ 61) }
  'writeString' { PT _ (TS _ 62) }
  '{' { PT _ (TS _ 63) }
  '}' { PT _ (TS _ 64) }
  '~=' { PT _ (TS _ 65) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_LIdent { PT _ (T_LIdent $$) }

tipi per gli attributi di $$
%attributetype {AttrT}
%attribute rexp { RExp }         -- 14 prod
%attribute lexp { LExp }         -- 1 prod
%attribute lRExp { [RExp] }      -- 1 prod
%attribute program { Program }   -- 1 prod
%attribute lPGlob { [PGlob] }    -- 1 prod
%attribute pglobl { PGlob }      -- 1 prod
%attribute pbool  { BasicType_Bool }

%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
String  :: { String }  : L_quoted {  $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
LIdent    :: { LIdent} : L_LIdent { LIdent ($1)}

Program :: { Program }
Program : ListPGlobl 
        { 
            $$.program = AbsBnfc.Prog $1;
        }

ListPGlobl :: { [PGlobl] }
ListPGlobl : 
                PGlobl 
        {   
            $$.PGlob = (:[]) $1; 
        }
                         
           | PGlobl ListPGlobl 
        { 
            $$.PGlob = (:) $1 $2; 
        }
PGlobl :: { PGlobl }
PGlobl : Stm 
        { 
            AbsBnfc.ProgGlobB $1 
        }
       | FuncD 
        { 
            AbsBnfc.ProgGlobF $1 
        }
                        

Block :: { Block }
Block : ListStm 
        { 
        AbsBnfc.Blk $1 
        }


ListStm :: { [Stm] }
ListStm : Stm 
        { 
            (:[]) $1
        } 
       | Stm ListStm 
        { 
            (:) $1 $2 
        }


BasicType :: { BasicType }
BasicType : 'Bool'
        { 
            $$.basicT = AbsBnfc.BasicType_Bool;
        }
          | 'Char' 
        { 
            $$.basicT = AbsBnfc.BasicType_Char;
        }
          | 'Float' 
        { 
            $$.basicT = AbsBnfc.BasicType_Float;
        }
          | 'Int' 
        { 
            $$.basicT = AbsBnfc.BasicType_Int;
        }
          | 'String' 
        { 
            $$.basicT = AbsBnfc.BasicType_String;
        }
          | 'Void' 
        { 
            $$.basicT = AbsBnfc.BasicType_Void;
        }


Boolean :: { Boolean }
Boolean : 'true' 
        { 
           $$ = AbsBnfc.Boolean_true;
        }
        | 'false' 
        { 
           $$ = AbsBnfc.Boolean_false;
        }


PtrVoid :: { PtrVoid }
PtrVoid : 'nil' 
        { 
          $$ = AbsBnfc.PtrType;
        }


Stm :: { Stm }
Stm : Decl ';' 
        { 
            $$.stm = AbsBnfc.SDecl $1 
        }
    | Local ';' 
        { 
            $$.stm = AbsBnfc.SLocal $1 
        }
    | Ass ';' 
        { 
           $$.stm = AbsBnfc.SAss $1 
        }
    | While 
        { 
           $$.stm = AbsBnfc.SWhile $1 
        }
    | Repeat ';' 
        { 
           $$.stm = AbsBnfc.SRepeat $1 
        }
    | For 
        { 
           $$.stm = AbsBnfc.SFor $1 
        }
    | If 
        { 
           $$.stm = AbsBnfc.SIf $1 
        }
    | RExp ';' 
        { 
           $$.stm = AbsBnfc.SRExp $1 
        }
    | EBlk 
        { 
           $$.stm = AbsBnfc.SEBlk $1 
        }
    | Return ';' 
        { 
           $$.stm = AbsBnfc.SReturn $1 
        }
    | Break ';' 
        { 
           $$.stm = AbsBnfc.SBreak $1 
        }


EBlk :: { EBlk }
EBlk : 'do' Block 'end' 
        { 
            $$.eblk = AbsBnfc.EBlkS $2 
        }


Decl :: { Decl }
Decl : BasicType LExp VarInit 
        { 
           $$.decl = AbsBnfc.DeclSP $1 $2 $3 
        }


VarInit :: { VarInit }
VarInit : {- empty -} 
        { 
          $$.varinit = AbsBnfc.VarINil 
        }
        | '=' RExp 
        { 
          $$.varinit =  AbsBnfc.VarExp $2 

        }


Local :: { Local }
Local : 'local' Decl 
        { 
           $$.local = AbsBnfc.DeclLocal $2 
        }


Ass :: { Ass }
Ass : LExp '=' RExp 
        { 
          $$.ass = AbsBnfc.AssD $1 $3 
        }


Func :: { Func }
Func : FuncWrite 
        { 
          $$.func = AbsBnfc.FuncBW $1 
        }
     | FuncRead 
        { 
          $$.func = AbsBnfc.FuncBR $1 
        }
     | LIdent '(' ListRExp ')' 
        { 
          $$.func = AbsBnfc.FnctCall $1 $3 
        }


FuncWrite :: { FuncWrite }
FuncWrite : 'writeInt' '(' RExp ')' 
        { 
           $$.funcwrite = AbsBnfc.WriteI $3 
        }
          | 'writeFloat' '(' RExp ')' 
        { 
           $$.funcwrite = AbsBnfc.WriteF $3 
        }
          | 'writeChar' '(' RExp ')' 
        { 
           $$.funcwrite = AbsBnfc.WriteC $3 
        }
          | 'writeString' '(' RExp ')' 
        { 
           $$.funcwrite = AbsBnfc.WriteS $3 
        }


FuncRead :: { FuncRead }
FuncRead : 'readInt' '(' ')' 
        { 
           $$.funcread = AbsBnfc.ReadI 
        }
         | 'readFloat' '(' ')' 
        { 
           $$.funcread = AbsBnfc.ReadF 
        }
         | 'readChar' '(' ')' 
        { 
           $$.funcread = AbsBnfc.ReadC 
        }
         | 'readString' '(' ')' 
        { 
           $$.funcread = AbsBnfc.ReadS 
        }


While :: { While }
While : 'while' RExp 'do' Block 'end' 
        { 
           $$.while = AbsBnfc.LoopW $2 $4 
        }


Repeat :: { Repeat }
Repeat : 'repeat' Block 'until' RExp 
        { 
          $$.repeat = AbsBnfc.LoopR $2 $4 
        }


For :: { For }
For : 'for' LIdent '=' RExp ',' RExp Increment 'do' Block 'end' 
        { 
           $$.for = AbsBnfc.LoopF $2 $4 $6 $7 $9 
        }
    | 'for' LIdent 'in' LIdent 'do' Block 'end' 
        { 
           $$.for =  AbsBnfc.LoopFE $2 $4 $6 
        }


Increment :: { Increment }
Increment : {- empty -} 
        { 
           $$.inc =  AbsBnfc.FInc (ValInt 1) -- assumiamo che sia 1, appunto 
        }
          | ',' RExp 
        { 
           $$.inc =  AbsBnfc.FInc $2
        }


If :: { If }
If : 'if' RExp 'then' Block ListElseIf Else 'end' 
        { 
          $$.if =   AbsBnfc.IfM $2 $4 (reverse $5) $6 
        }


Else :: { Else }
Else : 'else' Block 
        { 
          $$.else =   AbsBnfc.ElseS $2 
        }
     | {- empty -} 
        { 
          $$.else =   AbsBnfc.ElseE 
        }


ElseIf :: { ElseIf }
ElseIf : 'elseif' RExp 'then' Block 
        { 
          $$.elseif =   AbsBnfc.ElseIfD $2 $4 
        }


ListElseIf :: { [ElseIf] }
ListElseIf : {- empty -} 
        { 
           $$.lelseif =  [] 
        }
           | ListElseIf ElseIf 
        { 
           $$.lelseif = flip (:) $1 $2 
        }


Return :: { Return }
Return : 'return' RValue 
        { 
           $$.return = AbsBnfc.JumpR $2 
        }


RValue :: { RValue }
RValue : {- empty -} 
        { 
           $$.Rvalue = AbsBnfc.JumpRE 
        }
       | RExp 
        { 
           $$.Rvalue = AbsBnfc.JumpRV $1 
        }


Break :: { Break }
Break : 'break' 
        { 
          $$.break = AbsBnfc.JumpB 
        }


ListRExp :: { [RExp] }
ListRExp : {- empty -} 
        { 
          $$.LRExp =  [] 
        }
         | RExp 
        { 
          $$.LRExp = (:[]) $1 
        }
         | RExp ',' ListRExp 
        { 
          $$.LRExp = (:) $1 $3 
        }


FuncD :: { FuncD }
FuncD : BasicType 'function' LIdent '(' ListParamF ')' Block 'end' 
        { 
          $$.FuncD =  AbsBnfc.FnctDecl $1 $3 $5 $7 
        }


ParamF :: { ParamF }
ParamF : Modality BasicType LExp 
        { 
          $$.paramF = AbsBnfc.ParmDeclF $1 $2 $3 
        }


ListParamF :: { [ParamF] }
ListParamF : {- empty -} 
        { 
          $$.LparamF = [] 
        }
           | ParamF 
        { 
        (:[]) $1 
        }
           | ParamF ',' ListParamF 
        { 
          $$.LparamF = (:) $1 $3 
        }


Modality :: { Modality }
Modality : {- empty -} { AbsBnfc.Modality1 }
         | 'val' { $$.modality = AbsBnfc.Modality_val }
         | 'ref' { $$.modality =  AbsBnfc.Modality_ref }
         | 'const' { $$.modality =  AbsBnfc.Modality_const }
         | 'res' { $$.modality =  AbsBnfc.Modality_res }
         | 'valres' { $$.modality =  AbsBnfc.Modality_valres }
         | 'name' { $$.modality =  AbsBnfc.Modality_name }


LExp :: { LExp }
LExp : LIdent { $$.LExp = AbsBnfc.LExpS $1 }
     | '*' LExp { $$.LExp = AbsBnfc.LExpDR $2 }
     | LIdent ListDim { $$.LExp = AbsBnfc.LExpA $1 $2 }


ListDim :: { [Dim] }
ListDim : Dim 
        { 
          $$.LDim =  (:[]) $1 
        }
         | Dim ListDim 
        { 
          $$.LDim = (:) $1 $2 
        }


Dim :: { Dim }
Dim : '[' Integer ']' 
        { 
           $$.Dim = AbsBnfc.Dims $2 
        }


RExp :: { RExp }
RExp : RExp 'or' RExp1 
        { 
           $$.RExp = AbsBnfc.Or $1 $3;
           $$.tipo = BasicType_Bool;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkBothBool $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
     | RExp1 'and' RExp2 
        { 
           $$.RExp = AbsBnfc.And $1 $3 ;
           $$.tipo = BasicType_Bool;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkBothBool $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
     | RExp1 
        { 
           $$.RExp = $1;
           $1.env = $$.env;
           $$.tipo = $1.tipo;
           $$.err = $1.err;
        }


RExp2 :: { RExp }
RExp2 : 'not' RExp3 
        { 
           $$.RExp = AbsBnfc.Not $2;
           $$.tipo = BasicType_Bool;
           $2.env = $$.env;
           $$.err = (checkIsBool $2.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $2))
            );
        } 
        | RExp3 
        { 
           $$.RExp = $1;
           $1.env = $$.env;
           $$.tipo = $1.tipo;
           $$.err = $1.err;
        }


RExp3 :: { RExp }
RExp3 : RExp3 '==' RExp5 
        { 
           $$.RExp = AbsBnfc.Eq $1 $3 ;
           $$.tipo = BasicType_Bool;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkBothBool $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
      | RExp3 '~=' RExp5 
        { 
           $$.RExp = AbsBnfc.Neq $1 $3 ;
           $$.tipo = BasicType_Bool;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkBothBool $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
      | RExp3 '<' RExp5 
        { 
           $$.RExp = AbsBnfc.Lt $1 $3 ;
           $$.tipo = BasicType_Bool;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkBothBool $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
      | RExp3 '<=' RExp5 
        { 
           $$.RExp = AbsBnfc.LtE $1 $3 ;
           $$.tipo = BasicType_Bool;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkBothBool $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
      | RExp3 '>' RExp5 
        { 
           $$.RExp = AbsBnfc.Gt $1 $3 ;
           $$.tipo = BasicType_Bool;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkBothBool $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
      | RExp3 '>=' RExp5 
        { 
           $$.RExp = AbsBnfc.GtE $1 $3 ;
           $$.tipo = BasicType_Bool;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkBothBool $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
      | RExp4 { 
          $$.RExp = $1;
          $1.env = $$.env;
          $$.tipo = $1.tipo; 
          $$.err = $1.err;
          }


RExp6 :: { RExp }
RExp6 : RExp6 '+' RExp7 
        { 
           $$.RExp = AbsBnfc.Add $1 $3;
           $$.tipo = (supType $1.tipo $2.tipo) ;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkNumeric $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
      | RExp6 '-' RExp7 
        { 
           $$.RExp = AbsBnfc.Sub $1 $3;
           $$.tipo = (supType $1.tipo $2.tipo) ;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkNumeric $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
      | RExp7 
        { 
          $$.RExp = $1; 
          $1.env = $$.env;
          $$.tipo = $1.tipo; 
          $$.err = $1.err;
        }


RExp7 :: { RExp }
RExp7 : RExp7 '*' RExp8 
        { 
           $$.RExp =  AbsBnfc.Mul $1 $3;
           $$.tipo = (supType $1.tipo $2.tipo) ;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkNumeric $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
      | RExp7 '/' RExp8 
        { 
           $$.RExp = AbsBnfc.Div $1 $3;
           $$.tipo = (supType $1.tipo $2.tipo) ;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkNotZero $3.tipo) ++ (checkNumeric $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $3))
            );
        }
      | RExp7 '%' RExp8 
        { 
           $$.RExp =  AbsBnfc.Rem $1 $3;
           $$.tipo = (supType $1.tipo $2.tipo) ;
           $1.env = $$.env;
           $3.env = $$.env;
           $$.err = (checkNotZero $3.tipo) ++ (checkInt $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3 ))
            );
        }
      | RExp8 
        { 
          $$.RExp = $1;
          $1.env = $$.env;
          $$.tipo = $1.tipo; 
          $$.err = $1.err;
        }


RExp8 :: { RExp }
RExp8 : RExp9 '^' RExp8 
        { 
          $$.RExp = AbsBnfc.Pow $1 $3;
          $$.tipo = (supType $1.tipo $2.tipo) ;
          $1.env = $$.env;
          $3.env = $$.env;
          $$.err = (checkBothZero $1.tipo $3.tipo) ++ (checkNumeric $1.tipo $3.tipo);
          where ( 
            if ($$.err == "") 
               then (Ok())
            else (Bad $ (prntErr $$.err $1 $3))
            );
        } 
      | RExp9 
        { 
          $$.RExp = $1;
          $1.env = $$.env; 
          $$.tipo = $1.tipo; 
          $$.err = $1.err;
        }


RExp9 :: { RExp }
RExp9 : '-' RExp10 
        { 
          $$.RExp = AbsBnfc.Neg $2;
          $$.tipo = $2.tipo;
          $2.env = $$.env;
          $$.err = (checkSingleNumeric $2.tipo);
        } 
      | RExp10 
        { 
          $$.RExp = $1;
          $$.tipo = $1.tipo;
          $1.env = $$.env;
          $$.err = $1.err;
        }


RExp10 :: { RExp }
RExp10 : Func 
        { 
           $$.RExp = AbsBnfc.FCall $1 ;

        }
       | RExp10 '..' RExp11 
        { 
            $$.RExp = AbsBnfc.FStrCnt $1 $3 
        }
       | '#' RExp11 
        { 
            $$.RExp = AbsBnfc.FLen $2 
        }
       | RExp11 
        { 
           $$.RExp =  $1 
        }


RExp11 :: { RExp }
RExp11 : Integer 
        { 
            $$.RExp = AbsBnfc.ValInt $1; 
            $$.tipo = BasicType_Int;
            $1.env = $$.env;
            $$.err = "";
        }
       | LExp 
        { 
            $$.RExp = AbsBnfc.ValVariable $1 ;
            $$.tipo = $1.tipo;
            $1.env = $$.env;
            $$.err = "";
        }
       | '&' LExp 
        { 
            $$.RExp = AbsBnfc.ValRef $2 
            $$.tipo = $2.tipo;
            $2.env = $$.env;
            $$.err = "";
        }
       | Double 
        { 
            $$.RExp = AbsBnfc.ValDouble $1 ;
            $$.tipo = BasicType_Float;
            $1.env = $$.env;
            $$.err = "";
        }
       | String 
        { 
            $$.RExp =  AbsBnfc.ValString $1 ;
            $$.tipo = BasicType_String;
            $1.env = $$.env;
            $$.err = "";
        }
       | Char 
        { 
            $$.RExp = AbsBnfc.ValChar $1 ;
            $$.tipo = BasicType_Char;
            $1.env = $$.env;
            $$.err = "";
        }
       | Boolean 
        { 
            $$.RExp = AbsBnfc.ValBoolean $1 ;
            $$.tipo = BasicType_Bool;
            $1.env = $$.env;
            $$.err = "";
        }
       | PtrVoid 
        { 
            $$.RExp = AbsBnfc.ValPtr $1 ;
            $$.tipo = BasicType_Void;
            $1.env = $$.env;
            $$.err = "";
        }
       | RExp12 
        { 
            $$.RExp = $1 ;
            $$.tipo = $1.tipo;
            $1.env = $$.env;
            $$.err = $1.err;
        }


RExp12 :: { RExp }
RExp12 : '{' Array '}' 
        { 
            $$.RExp = AbsBnfc.ValMArr $2 ;
            $$.tipo = $2.tipo;
            $2.env = $$.env;
            $$.err = $2.err;
        } 
        | RExp13 
        { 
            $$.RExp = $1 ;
            $$.tipo = $1.tipo;
            $1.env = $$.env;
            $$.err = $1.err;
        }


Array :: { Array }
Array : '{' Array '}' ',' Array 
        { 
            $$.Array = AbsBnfc.ArrayV0 $2 $5;
            $2.env = $$.env;
            $5.env = $$.env;
            
        }
      | '{' Array '}' 
        { 
            AbsBnfc.ArrayV1 $2 ;
            $$.tipo = $2.tipo;
            $2.env = $$.env;
            $$.err = $2.err;
        }
      | ListVType 
        { 
            AbsBnfc.ArrayV2 $1 ;
            $$.tipo = $1.tipo;
            $1.env = $$.env;
            $$.err = (checkTypeSubElements );
        }


VType :: { VType }      --una dummy qui?
VType : Boolean { $$.VType = AbsBnfc.VTypeBoolean $1 }
      | Char { $$.VType =  AbsBnfc.VTypeChar $1 }
      | Double { $$.VType =  AbsBnfc.VTypeDouble $1 }
      | Integer { $$.VType =  AbsBnfc.VTypeInteger $1 }
      | String { $$.VType =  AbsBnfc.VTypeString $1 }
      | PtrVoid { $$.VType =  AbsBnfc.VTypePtrVoid $1 }
      | {- empty -} { $$.VType =  AbsBnfc.VType1 }


ListVType :: { [VType] }
ListVType : VType 
        { 
            $$.VType = (:[]) $1 
        } 
        | VType ',' ListVType 
        { 
            $$.VType = (:) $1 $3 
        }


RExp1 :: { RExp }
RExp1 : RExp2 
        { 
            $$.RExp = $1 ;
            $$.tipo = $1.tipo;
            $1.env = $$.env;
            $$.err = $1.err;
        }


RExp4 :: { RExp }
RExp4 : RExp5 
        { 
            $$.RExp = $1 ;
            $$.tipo = $1.tipo;
            $1.env = $$.env;
            $$.err = $1.err; 
        }


RExp5 :: { RExp }
RExp5 : RExp6 
        { 
            $$.RExp = $1 ;
            $$.tipo = $1.tipo;
            $1.env = $$.env;
            $$.err = $1.err;
        }


RExp13 :: { RExp }
RExp13 : '(' RExp ')' 
        { 
            $$.RExp = $2 ;
            $$.tipo = $2.tipo;
            $2.env = $$.env;
            $$.err = $2.err; 
        }


{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

