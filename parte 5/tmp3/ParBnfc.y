-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParBnfc where
import AbsBnfc
import LexBnfc
import ErrM
import Utils
import Data.Maybe
import Env

}

%name pProgram Program
%name pListPGlobl ListPGlobl
%name pPGlobl PGlobl
%name pBlock Block
%name pListStm ListStm
%name pBasicType BasicType
%name pBoolean Boolean
%name pPtrVoid PtrVoid
%name pStm Stm
%name pEBlk EBlk
%name pDecl Decl
%name pVarInit VarInit
%name pLocal Local
%name pAss Ass
%name pFunc Func
%name pFuncWrite FuncWrite
%name pFuncRead FuncRead
%name pWhile While
%name pRepeat Repeat
%name pFor For
%name pIncrement Increment
%name pIf If
%name pElse Else
%name pElseIf ElseIf
%name pListElseIf ListElseIf
%name pReturn Return
%name pRValue RValue
%name pBreak Break
%name pListRExp ListRExp
%name pFuncD FuncD
%name pParamF ParamF
%name pListParamF ListParamF
%name pModality Modality
%name pLExp LExp
%name pListDim ListDim
%name pDim Dim
%name pRExp RExp
%name pRExp2 RExp2
%name pRExp3 RExp3
%name pRExp6 RExp6
%name pRExp7 RExp7
%name pRExp8 RExp8
%name pRExp9 RExp9
%name pRExp10 RExp10
%name pRExp11 RExp11
%name pRExp12 RExp12
%name pArray Array
%name pVType VType
%name pListVType ListVType
%name pRExp1 RExp1
%name pRExp4 RExp4
%name pRExp5 RExp5
%name pRExp13 RExp13
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '..' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '<=' { PT _ (TS _ 14) }
  '=' { PT _ (TS _ 15) }
  '==' { PT _ (TS _ 16) }
  '>' { PT _ (TS _ 17) }
  '>=' { PT _ (TS _ 18) }
  'Bool' { PT _ (TS _ 19) }
  'Char' { PT _ (TS _ 20) }
  'Float' { PT _ (TS _ 21) }
  'Int' { PT _ (TS _ 22) }
  'String' { PT _ (TS _ 23) }
  'Void' { PT _ (TS _ 24) }
  '[' { PT _ (TS _ 25) }
  ']' { PT _ (TS _ 26) }
  '^' { PT _ (TS _ 27) }
  'and' { PT _ (TS _ 28) }
  'break' { PT _ (TS _ 29) }
  'const' { PT _ (TS _ 30) }
  'do' { PT _ (TS _ 31) }
  'else' { PT _ (TS _ 32) }
  'elseif' { PT _ (TS _ 33) }
  'end' { PT _ (TS _ 34) }
  'false' { PT _ (TS _ 35) }
  'for' { PT _ (TS _ 36) }
  'function' { PT _ (TS _ 37) }
  'if' { PT _ (TS _ 38) }
  'in' { PT _ (TS _ 39) }
  'local' { PT _ (TS _ 40) }
  'name' { PT _ (TS _ 41) }
  'nil' { PT _ (TS _ 42) }
  'not' { PT _ (TS _ 43) }
  'or' { PT _ (TS _ 44) }
  'readChar' { PT _ (TS _ 45) }
  'readFloat' { PT _ (TS _ 46) }
  'readInt' { PT _ (TS _ 47) }
  'readString' { PT _ (TS _ 48) }
  'ref' { PT _ (TS _ 49) }
  'repeat' { PT _ (TS _ 50) }
  'res' { PT _ (TS _ 51) }
  'return' { PT _ (TS _ 52) }
  'then' { PT _ (TS _ 53) }
  'true' { PT _ (TS _ 54) }
  'until' { PT _ (TS _ 55) }
  'val' { PT _ (TS _ 56) }
  'valres' { PT _ (TS _ 57) }
  'while' { PT _ (TS _ 58) }
  'writeChar' { PT _ (TS _ 59) }
  'writeFloat' { PT _ (TS _ 60) }
  'writeInt' { PT _ (TS _ 61) }
  'writeString' { PT _ (TS _ 62) }
  '{' { PT _ (TS _ 63) }
  '}' { PT _ (TS _ 64) }
  '~=' { PT _ (TS _ 65) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_LIdent { PT _ (T_LIdent _) }

-- tipi per gli attributi di $$
%attributetype { AttrTree a }
%attribute res { Result }
%attribute parsetree { a }
%attribute vint { Integer }
%attribute vdbl { Double }
%attribute vchr { Char }
%attribute vstr { String }
%attribute vlident { LIdent }

-- attributi per il frontend
%attribute envin { EnvT }
%attribute envout { EnvT }
%attribute errs { [String] }
%attribute posn { Posn }
%attribute tipo { BasicType }


%%

Integer : L_integ  { $$.vint = (read ( $1)) :: Integer }

Double : L_doubl  {  $$.vdbl = (read ( $1)) :: Double }

String : L_quoted { $$.vstr = $1 }

Char : L_charac {  $$.vchr = (read ( $1)) :: Char }

LIdent : L_LIdent 
{         
            $$.posn =  (tokenPosn $1)                           
            ; $$.vlident = LIdent (getLIdentT $1)
        }

Program : ListPGlobl
    { 
        $1.envin = emptyEnv
        ; $$.res = Result (AbsBnfc.Prog $1.parsetree ) "qui TAC" $1.envout $1.errs
    }

ListPGlobl : PGlobl 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = (:[]) $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    } 
    | PGlobl ListPGlobl
    { 
        $1.envin = $$.envin
        ; $2.envin = $1.envout
        ; $$.parsetree = (:) $1.parsetree $2.parsetree
        ; $$.envout = mergeEnv $1.envout $2.envout
        ; $$.errs = $1.errs ++ $2.errs
        
    }

PGlobl : Stm 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsBnfc.ProgGlobB $1.parsetree
        ; $$.envout = $1.envout 
        ; $$.errs = $1.errs
    }
       | FuncD 
    { 
        $$.parsetree = AbsBnfc.ProgGlobF $1.parsetree
        ; $1.envin = $$.envin 
        ; $$.envout = $1.envout 
        ; $$.errs = $1.errs
    }

Block : ListStm 
    { 
        $$.parsetree = AbsBnfc.Blk $1.parsetree 
    }

ListStm : Stm 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    } 
    | Stm ListStm 
    { 
        $$.parsetree = (:) $1.parsetree $2.parsetree
    }

BasicType : 'Bool' 
    { 
        $$.parsetree = AbsBnfc.BasicType_Bool 
    }
    | 'Char' 
    { 
        $$.parsetree = AbsBnfc.BasicType_Char 
    }
    | 'Float' 
    { 
        $$.parsetree = AbsBnfc.BasicType_Float 
    }
    | 'Int' 
    { 
        $$.parsetree = AbsBnfc.BasicType_Int 
    }
    | 'String' 
    { 
        $$.parsetree = AbsBnfc.BasicType_String 
    }
    | 'Void' 
    { 
        $$.parsetree = AbsBnfc.BasicType_Void 
    }

Boolean : 'true' { $$.parsetree = AbsBnfc.Boolean_true }
        | 'false' { $$.parsetree = AbsBnfc.Boolean_false }

PtrVoid : 'nil' { $$.parsetree = AbsBnfc.PtrType }

Stm : Decl ';' 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsBnfc.SDecl $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | Local ';' 
    { 
        $$.parsetree = AbsBnfc.SLocal $1.parsetree 
    }
    | Ass ';' 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsBnfc.SAss $1.parsetree 
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | While 
    { 
        $$.parsetree = AbsBnfc.SWhile $1.parsetree 
    }
    | Repeat ';' 
    { 
        $$.parsetree = AbsBnfc.SRepeat $1.parsetree 
    }
    | For 
    { 
        $$.parsetree = AbsBnfc.SFor $1.parsetree 
    }
    | If 
    { 
        $$.parsetree = AbsBnfc.SIf $1.parsetree 
    }
    | RExp ';' 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsBnfc.SRExp $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
    }
    | EBlk 
    { 
        $$.parsetree = AbsBnfc.SEBlk $1.parsetree 
    }
    | Return ';' 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsBnfc.SReturn $1.parsetree
        ; 
    }
    | Break ';' 
    { 
        $$.parsetree = AbsBnfc.SBreak $1.parsetree
    }

EBlk : 'do' Block 'end' 
    { 
        $$.parsetree = AbsBnfc.EBlkS $2.parsetree 
    }

-- passa a VarInit env e varie
Decl : BasicType LExp VarInit 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.DeclSP $1.parsetree $2.parsetree $3.parsetree
        ; $$.envout = ( if (isOk (insertEnv $1.parsetree $2.parsetree $$.envin $2.posn))
                         then (fromOk (insertEnv $1.parsetree $2.parsetree $$.envin $2.posn))
                         else $3.envin
                        )
        ; $$.errs = ( if (isJust (lookupEnv ( (fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                         then ["error: variable " ++ (fromBad (insertEnv $1.parsetree $2.parsetree $$.envin $2.posn))]
                         else []
                        ) ++ $3.errs
                            
    }

VarInit : {- empty -} 
    { 
        
        $$.parsetree = AbsBnfc.VarINil
        ; $$.envout = $$.envin
        ; $$.errs = []
    }
    | '=' RExp 
    {
        $$.parsetree = AbsBnfc.VarExp $2.parsetree 
        ; $$.envout = $$.envin
        ; $$.errs = []
    }

Local : 'local' Decl 
    { 
        $$.parsetree = AbsBnfc.DeclLocal $2.parsetree 
    }

Ass : LExp '=' RExp 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.AssD $1.parsetree $3.parsetree
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                        then (if ((isVarEnv . head . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                then ((getTypeV . head . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                else BasicType_Void )
                        else BasicType_Void )
        ; $$.errs = (if ($$.tipo == BasicType_Void)
                         then []
                         else if ($$.tipo == $3.tipo)
                                  then []
                                  else ["error at " ++ ((showFromPosn . tokenPosn) $2) ++ ": expects argument of type '" ++ (showBBType $$.tipo) ++ "' but has type '"++ (showBBType $3.tipo) ++"'"]) ++ $3.errs
        ; $$.envout = $3.envout 
    }


Func : FuncWrite 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsBnfc.FuncBW $1.parsetree
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
        ; $$.tipo = AbsBnfc.BasicType_Void
    }
    | FuncRead 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsBnfc.FuncBR $1.parsetree 
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }
    | LIdent '(' ListRExp ')' --modded
    { 
        $$.parsetree = AbsBnfc.FnctCall $1.vlident $3.parsetree 
    }

FuncWrite : 'writeInt' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.WriteI $3.parsetree 
        ; $$.envout = $3.envout
        ; $$.errs = (if (not($3.tipo == BasicType_Int))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeInt' need to be Int!"]
                        else []
                     ) ++ $3.errs
    }
    | 'writeFloat' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.WriteF $3.parsetree
        ; $$.envout = $3.envout
        ; $$.errs = (if (not ($3.tipo == BasicType_Float))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeFloat' need to be Float!"]
                        else []
                     ) ++ $3.errs
    }
    | 'writeChar' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.WriteC $3.parsetree
        ; $$.envout = $3.envout
        ; $$.errs = (if (not ($3.tipo == BasicType_Char))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeChar' need to be Char!"]
                        else []
                     ) ++ $3.errs
    }
    | 'writeString' '(' RExp ')' 
    { 
        $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.WriteS $3.parsetree
        ; $$.envout = $3.envout
        ; $$.errs = (if (not ($3.tipo == BasicType_String))
                        then ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type for 'writeString' need to be String!"]
                        else []
                     ) ++ $3.errs
    }

FuncRead : 'readInt' '(' ')' 
    { 
        $$.parsetree = AbsBnfc.ReadI
        ; $$.tipo = BasicType_Int
        ; $$.errs = []
        ; $$.envout = $$.envin
    }
    | 'readFloat' '(' ')' 
    { 
        $$.parsetree = AbsBnfc.ReadF
        ; $$.tipo = BasicType_Float
        ; $$.errs = []
        ; $$.envout = $$.envin
    }
    | 'readChar' '(' ')' 
    { 
        $$.parsetree = AbsBnfc.ReadC
        ; $$.tipo = BasicType_Char
        ; $$.errs = []
        ; $$.envout = $$.envin 
    }
    | 'readString' '(' ')' 
    { 
        $$.parsetree = AbsBnfc.ReadS
        ; $$.tipo = BasicType_String
        ; $$.errs = []
        ; $$.envout = $$.envin 
    }

While : 'while' RExp 'do' Block 'end' 
    { 
        $$.parsetree = AbsBnfc.LoopW $2.parsetree $4.parsetree 
    }

Repeat : 'repeat' Block 'until' RExp 
    { 
        $$.parsetree = AbsBnfc.LoopR $2.parsetree $4.parsetree 
    }

For : 'for' LIdent '=' RExp ',' RExp Increment 'do' Block 'end' --modded
    { 
        $$.parsetree = AbsBnfc.LoopF $2.vlident $4.parsetree $6.parsetree $7.parsetree $9.parsetree 
    }
    | 'for' LIdent 'in' LIdent 'do' Block 'end' --modded
    { 
        $$.parsetree = AbsBnfc.LoopFE $2.vlident $4.vlident $6.parsetree 
    }

Increment : {- empty -} -- per l'appunto, assumiamo sia 1 l'incremento
    { 
        $$.parsetree = AbsBnfc.FInc ( AbsBnfc.ValInt 1 )
    }
    | ',' RExp 
    { 
        $$.parsetree = AbsBnfc.FInc $2.parsetree 
    }

If : 'if' RExp 'then' Block ListElseIf Else 'end' --occhio al $5
    { 
        $$.parsetree = AbsBnfc.IfM $2.parsetree $4.parsetree (reverse $5.parsetree) $6.parsetree    
    }

Else : 'else' Block 
    { 
        $$.parsetree = AbsBnfc.ElseS $2.parsetree 
    }
    | {- empty -} 
    { 
        $$.parsetree = AbsBnfc.ElseE 
    }

ElseIf : 'elseif' RExp 'then' Block 
    { 
        $$.parsetree = AbsBnfc.ElseIfD $2.parsetree $4.parsetree 
    }

ListElseIf : {- empty -} 
    { 
        $$.parsetree = [] 
    }
    | ListElseIf ElseIf 
    { 
        $$.parsetree = flip (:) $1.parsetree $2.parsetree 
    }

Return : 'return' RValue 
    { 
        $$.parsetree = AbsBnfc.JumpR $2.parsetree 
    }

RValue : {- empty -} 
    { 
        $$.parsetree = AbsBnfc.JumpRE 
    }
    | RExp 
    { 
        $$.parsetree = AbsBnfc.JumpRV $1.parsetree 
    }

Break : 'break' 
    { 
        $$.parsetree = AbsBnfc.JumpB 
    }

ListRExp : {- empty -} 
    { 
        $$.parsetree = [] 
    }
    | RExp 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    }
    | RExp ',' ListRExp 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree 
    }

FuncD : BasicType 'function' LIdent '(' ListParamF ')' Block 'end' --modded
    { 
        $$.parsetree = AbsBnfc.FnctDecl $1.parsetree $3.vlident $5.parsetree $7.parsetree 
    }

ParamF : Modality BasicType LExp 
    { 
        $$.parsetree = AbsBnfc.ParmDeclF $1.parsetree $2.parsetree $3.parsetree 
    }

ListParamF : {- empty -} 
    { 
        $$.parsetree = [] 
    }
    | ParamF 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    }
    | ParamF ',' ListParamF 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree 
    }

Modality : {- empty -} 
    { 
        $$.parsetree = AbsBnfc.Modality1 
    }
    | 'val' 
    { 
        $$.parsetree = AbsBnfc.Modality_val
    }
    | 'ref' 
    { 
        $$.parsetree = AbsBnfc.Modality_ref 
    }
    | 'const' 
    { 
        $$.parsetree = AbsBnfc.Modality_const 
    }
    | 'res' 
    { 
        $$.parsetree = AbsBnfc.Modality_res 
    }
    | 'valres' 
    { 
        $$.parsetree = AbsBnfc.Modality_valres 
    }
    | 'name' 
    { 
        $$.parsetree = AbsBnfc.Modality_name 
    }

LExp : LIdent --modded
    { 
        $$.parsetree = AbsBnfc.LExpS $1.vlident
        ; $$.posn = $1.posn
    }
    | '*' LExp 
    { 
        $$.parsetree = AbsBnfc.LExpDR $2.parsetree 
        ; $$.posn = $2.posn
    }
    | LIdent ListDim --modded
    { 
        $$.parsetree = AbsBnfc.LExpA $1.vlident $2.parsetree
        ; $$.posn = $1.posn
    }

ListDim : Dim 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    } 
    | Dim ListDim 
    { 
        $$.parsetree = (:) $1.parsetree $2.parsetree 
    }

Dim : '[' Integer ']' --modded
    { 
        $$.parsetree = AbsBnfc.Dims $2.vint 
    }

RExp : RExp 'or' RExp1 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Or $1.parsetree $3.parsetree
        ; $$.errs = (if (($1.tipo == BasicType_Bool) && ($3.tipo == BasicType_Bool))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for 'or' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = BasicType_Bool 
    }
    | RExp1 'and' RExp2 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.And $1.parsetree $3.parsetree
        ; $$.errs = (if (($1.tipo == BasicType_Bool) && ($3.tipo == BasicType_Bool))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for 'and' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = BasicType_Bool
    }
    | RExp1 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo 
    }

RExp2 : 'not' RExp3 
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Not $2.parsetree
        ; $$.errs = (if ($2.tipo == BasicType_Bool)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $1) ++ ": type need to be compatible for 'and' operations!"]) ++ $2.errs
        ; $$.envout = $2.envout
        ; $$.tipo = BasicType_Bool
    } 
    | RExp3 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo 
    }

RExp3 : RExp3 '==' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Eq $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '==' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = BasicType_Bool 
    }
    | RExp3 '~=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Neq $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '~=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = BasicType_Bool 
    }
    | RExp3 '<' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Lt $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '<' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = BasicType_Bool
    }
    | RExp3 '<=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.LtE $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '<=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = BasicType_Bool
    }
    | RExp3 '>' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Gt $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '>' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = BasicType_Bool
    }
    | RExp3 '>=' RExp5 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.GtE $1.parsetree $3.parsetree
        ; $$.errs = (if (isValidCmp $1.tipo $3.tipo)
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be compatible for '>=' operations!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = BasicType_Bool
    }
    | RExp4 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo 
    }

RExp6 : RExp6 '+' RExp7 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Add $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = (if (($1.tipo == BasicType_Float) || ($3.tipo == BasicType_Float))
                         then BasicType_Float
                         else BasicType_Int )  
    }
    | RExp6 '-' RExp7 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Sub $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = (if (($1.tipo == BasicType_Float) || ($3.tipo == BasicType_Float))
                         then BasicType_Float
                         else BasicType_Int )  
    }
    | RExp7 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo 
    }

RExp7 : RExp7 '*' RExp8 
    { 
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Mul $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = (if (($1.tipo == BasicType_Float) || ($3.tipo == BasicType_Float))
                         then BasicType_Float
                         else BasicType_Int ) 
    }
    | RExp7 '/' RExp8 
    {
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Div $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = (if (($1.tipo == BasicType_Float) || ($3.tipo == BasicType_Float))
                         then BasicType_Float
                         else BasicType_Int )
    }
    | RExp7 '%' RExp8 
    {   
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Rem $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = BasicType_Int
    }
    | RExp8 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo 
    }

RExp8 : RExp9 '^' RExp8 
    {   
        $1.envin = $$.envin
        ; $3.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Pow $1.parsetree $3.parsetree
        ; $$.errs = (if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then []
                         else ["error at "++ ((showFromPosn . tokenPosn) $2) ++ ": type need to be Int or Float!"]) ++ $1.errs ++ $3.errs
        ; $$.envout = $1.envout
        ; $$.tipo = ( if ((($1.tipo == BasicType_Int) || ($1.tipo == BasicType_Float)) && (($3.tipo == BasicType_Int) || ($3.tipo == BasicType_Float)))
                         then $1.tipo
                         else BasicType_Float )
    } 
    | RExp9 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo
    }

RExp9 : '-' RExp10 -- tipo numerico!! per il momento lasciamo sia int o float
    { 
        $2.envin = $$.envin
        ; $$.parsetree = AbsBnfc.Neg $2.parsetree
        ; $$.errs = ( if (($2.tipo == BasicType_Int) || ($2.tipo == BasicType_Float))
                         then []
                         else ["error at " ++ ((showFromPosn . tokenPosn) $1) ++ ": type need to be Int or Float!"]   ) ++ $2.errs
        ; $$.envout = $2.envout
        ; $$.tipo = ( if (($2.tipo == BasicType_Int) || ($2.tipo == BasicType_Float))
                         then $2.tipo
                         else BasicType_Float )
    } 
    | RExp10 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo 
    }

RExp10 : Func --TODO: sistema la roba dentro func
    { 
        $1.envin = $$.envin
        ; $$.parsetree = AbsBnfc.FCall $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo
    }
    | RExp10 '..' RExp11 -- temporaneamente ignorato
    { 
        $$.parsetree = AbsBnfc.FStrCnt $1.parsetree $3.parsetree 
    }
    | '#' RExp11 -- temporaneamente ignorato
    { 
        $$.parsetree = AbsBnfc.FLen $2.parsetree 
    }
    | RExp11 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo
    }

RExp11 : Integer --modded
    { 
        $$.parsetree = AbsBnfc.ValInt $1.vint
        ; $$.tipo = BasicType_Int
        ; $$.envout = $$.envin
        ; $$.errs = []
    }
    | LExp 
    { 
        $$.parsetree = AbsBnfc.ValVariable $1.parsetree 
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                        then (if ((isVarEnv . head . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                then ((getTypeV . head . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $1.parsetree) $$.envin))
                                else BasicType_Void )
                        else BasicType_Void ) 
        ; $$.envout = $$.envin
        ; $$.errs = (if ($$.tipo == BasicType_Void)
                        then ["error: reference to " ++ ((fromLIdent . getLIdentlexp) $1.parsetree) ++ " at line " ++
                                (showFromPosn $1.posn) ++ "is invalid (maybe a function or not declared variable?)"]
                        else [])
    }
    | '&' LExp 
    { 
        $$.parsetree = AbsBnfc.ValRef $2.parsetree
        ; $$.envout = $$.envin
        ; $$.tipo = (if (isJust (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                        then (if ((isVarEnv . head . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                                then ((getTypeV . head . fromJust) (lookupEnv ((fromLIdent . getLIdentlexp) $2.parsetree) $$.envin))
                                else BasicType_Void )
                        else BasicType_Void )
        ; $$.errs = (if ($$.tipo == BasicType_Void)
                        then ["error: reference to " ++ ((fromLIdent . getLIdentlexp) $2.parsetree) ++ " at line " ++
                                (showFromPosn $2.posn) ++ "is invalid (maybe a function or not declared variable?)"]
                        else [])
    }
    | Double --modded
    { 
        $$.parsetree = AbsBnfc.ValDouble $1.vdbl
        ; $$.tipo = BasicType_Float
        ; $$.envout = $$.envin
        ; $$.errs = []
    }
    | String --modded
    { 
        $$.parsetree = AbsBnfc.ValString $1.vstr
        ; $$.tipo = BasicType_String
        ; $$.envout = $$.envin
        ; $$.errs = []
    }
    | Char --modded
    { 
        $$.parsetree = AbsBnfc.ValChar $1.vchr
        ; $$.tipo = BasicType_Char
        ; $$.envout = $$.envin
        ; $$.errs = []
    }
    | Boolean 
    { 
        $$.parsetree = AbsBnfc.ValBoolean $1.parsetree
        ; $$.tipo = BasicType_Int
        ; $$.envout = $$.envin
        ; $$.errs = []
    }
    | PtrVoid 
    { 
        $$.parsetree = AbsBnfc.ValPtr $1.parsetree
        ; $$.tipo = BasicType_Void
        ; $$.envout = $$.envin
        ; $$.errs = []
    }
    | RExp12 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree 
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }

RExp12 : '{' Array '}' --temporaneamente non tipo
    { 
        $$.parsetree = AbsBnfc.ValMArr $2.parsetree 
    } 
    | RExp13 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree 
        ; $$.envout = $1.envout
        ; $$.errs = $1.errs
        ; $$.tipo = $1.tipo
    }

-- temporaneamente sospeso il tipo
Array : '{' Array '}' ',' Array 
    { 
        $$.parsetree = AbsBnfc.ArrayV0 $2.parsetree $5.parsetree 
    }
    | '{' Array '}' 
    { 
        $$.parsetree = AbsBnfc.ArrayV1 $2.parsetree 
    }
    | ListVType 
    { 
        $$.parsetree = AbsBnfc.ArrayV2 $1.parsetree 
    }

VType : Boolean 
    { 
        $$.parsetree = AbsBnfc.VTypeBoolean $1.parsetree 
    }
    | Char --modded
    { 
        $$.parsetree = AbsBnfc.VTypeChar $1.vchr 
    }
    | Double --modded
    { 
        $$.parsetree = AbsBnfc.VTypeDouble $1.vdbl 
    }
    | Integer --modded
    { 
        $$.parsetree = AbsBnfc.VTypeInteger $1.vint
    }
    | String --modded
    { 
        $$.parsetree = AbsBnfc.VTypeString $1.vstr 
    }
    | PtrVoid 
    { 
        $$.parsetree = AbsBnfc.VTypePtrVoid $1.parsetree 
    }
    | {- empty -} 
    { 
        $$.parsetree = AbsBnfc.VType1 
    }

ListVType : VType 
    { 
        $$.parsetree = (:[]) $1.parsetree 
    } 
    | VType ',' ListVType 
    { 
        $$.parsetree = (:) $1.parsetree $3.parsetree 
    }

--rexp continuo a tipare

RExp1 : RExp2 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo
    }

RExp4 : RExp5 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo 
    }

RExp5 : RExp6 
    { 
        $1.envin = $$.envin
        ; $$.parsetree = $1.parsetree
        ; $$.errs = $1.errs
        ; $$.envout = $1.envout
        ; $$.tipo = $1.tipo 
    }

RExp13 : '(' RExp ')' 
    { 
        $2.envin = $$.envin
        ; $$.parsetree = $2.parsetree
        ; $$.errs = $2.errs
        ; $$.envout = $2.envout
        ; $$.tipo = $2.tipo 
    }
{

data Result = Result Program String EnvT [String]  deriving (Eq, Show)


returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

