-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParAuL where
import AbsAuL
import LexAuL
import ErrM

}

%name pProgram Program
%name pListPGlobl ListPGlobl
%name pPGlobl PGlobl
%name pBlock Block
%name pListStm ListStm
%name pBasicType BasicType
%name pBoolean Boolean
%name pPtrVoid PtrVoid
%name pCompoundType CompoundType
%name pBracks Bracks
%name pListBracks ListBracks
%name pStm Stm
%name pEBlk EBlk
%name pDecl Decl
%name pVarInit VarInit
%name pArray Array
%name pVType VType
%name pListVType ListVType
%name pListArray ListArray
%name pLocal Local
%name pAss Ass
%name pFunc Func
%name pFuncWrite FuncWrite
%name pFuncRead FuncRead
%name pWhile While
%name pRepeat Repeat
%name pFor For
%name pIncrement Increment
%name pIf If
%name pElse Else
%name pElseIf ElseIf
%name pListElseIf ListElseIf
%name pReturn Return
%name pRValue RValue
%name pBreak Break
%name pListRExp ListRExp
%name pFuncD FuncD
%name pParamF ParamF
%name pListParamF ListParamF
%name pModality Modality
%name pLExp LExp
%name pListDim ListDim
%name pDim Dim
%name pRExp RExp
%name pRExp1 RExp1
%name pRExp2 RExp2
%name pRExp4 RExp4
%name pRExp6 RExp6
%name pRExp7 RExp7
%name pRExp8 RExp8
%name pRExp9 RExp9
%name pRExp10 RExp10
%name pRExp11 RExp11
%name pRExp3 RExp3
%name pRExp5 RExp5
%name pRExp12 RExp12
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '#' { PT _ (TS _ 1) }
  '%' { PT _ (TS _ 2) }
  '&' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '..' { PT _ (TS _ 10) }
  '/' { PT _ (TS _ 11) }
  ':' { PT _ (TS _ 12) }
  ';' { PT _ (TS _ 13) }
  '<' { PT _ (TS _ 14) }
  '<=' { PT _ (TS _ 15) }
  '=' { PT _ (TS _ 16) }
  '==' { PT _ (TS _ 17) }
  '>' { PT _ (TS _ 18) }
  '>=' { PT _ (TS _ 19) }
  '?' { PT _ (TS _ 20) }
  'Bool' { PT _ (TS _ 21) }
  'Char' { PT _ (TS _ 22) }
  'Float' { PT _ (TS _ 23) }
  'Int' { PT _ (TS _ 24) }
  'String' { PT _ (TS _ 25) }
  'Void' { PT _ (TS _ 26) }
  '[' { PT _ (TS _ 27) }
  ']' { PT _ (TS _ 28) }
  '^' { PT _ (TS _ 29) }
  'and' { PT _ (TS _ 30) }
  'break' { PT _ (TS _ 31) }
  'const' { PT _ (TS _ 32) }
  'do' { PT _ (TS _ 33) }
  'else' { PT _ (TS _ 34) }
  'elseif' { PT _ (TS _ 35) }
  'end' { PT _ (TS _ 36) }
  'false' { PT _ (TS _ 37) }
  'for' { PT _ (TS _ 38) }
  'function' { PT _ (TS _ 39) }
  'if' { PT _ (TS _ 40) }
  'local' { PT _ (TS _ 41) }
  'name' { PT _ (TS _ 42) }
  'nil' { PT _ (TS _ 43) }
  'not' { PT _ (TS _ 44) }
  'or' { PT _ (TS _ 45) }
  'readChar' { PT _ (TS _ 46) }
  'readFloat' { PT _ (TS _ 47) }
  'readInt' { PT _ (TS _ 48) }
  'readString' { PT _ (TS _ 49) }
  'repeat' { PT _ (TS _ 50) }
  'res' { PT _ (TS _ 51) }
  'return' { PT _ (TS _ 52) }
  'then' { PT _ (TS _ 53) }
  'true' { PT _ (TS _ 54) }
  'until' { PT _ (TS _ 55) }
  'val' { PT _ (TS _ 56) }
  'valres' { PT _ (TS _ 57) }
  'while' { PT _ (TS _ 58) }
  'writeChar' { PT _ (TS _ 59) }
  'writeFloat' { PT _ (TS _ 60) }
  'writeInt' { PT _ (TS _ 61) }
  'writeString' { PT _ (TS _ 62) }
  '{' { PT _ (TS _ 63) }
  '}' { PT _ (TS _ 64) }
  '~=' { PT _ (TS _ 65) }
  L_charac { PT _ (TC $$) }
  L_doubl  { PT _ (TD $$) }
  L_integ  { PT _ (TI $$) }
  L_quoted { PT _ (TL $$) }
  L_LIdent { PT _ (T_LIdent $$) }

%%

Char    :: { Char }
Char     : L_charac { (read ( $1)) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read ( $1)) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read ( $1)) :: Integer }

String  :: { String }
String   : L_quoted {  $1 }

LIdent :: { LIdent}
LIdent  : L_LIdent { LIdent ($1)}

Program :: { Program }
Program : ListPGlobl { AbsAuL.Prog $1 }
ListPGlobl :: { [PGlobl] }
ListPGlobl : PGlobl { (:[]) $1 } | PGlobl ListPGlobl { (:) $1 $2 }
PGlobl :: { PGlobl }
PGlobl : Stm { AbsAuL.ProgGlobB $1 }
       | FuncD { AbsAuL.ProgGlobF $1 }
Block :: { Block }
Block : ListStm { AbsAuL.Blk (reverse $1) }
ListStm :: { [Stm] }
ListStm : {- empty -} { [] } | ListStm Stm { flip (:) $1 $2 }
BasicType :: { BasicType }
BasicType : 'Bool' { AbsAuL.BasicType_Bool }
          | 'Char' { AbsAuL.BasicType_Char }
          | 'Float' { AbsAuL.BasicType_Float }
          | 'Int' { AbsAuL.BasicType_Int }
          | 'String' { AbsAuL.BasicType_String }
          | 'Void' { AbsAuL.BasicType_Void }
Boolean :: { Boolean }
Boolean : 'true' { AbsAuL.Boolean_true }
        | 'false' { AbsAuL.Boolean_false }
PtrVoid :: { PtrVoid }
PtrVoid : 'nil' { AbsAuL.PtrType }
CompoundType :: { CompoundType }
CompoundType : BasicType { AbsAuL.CompTypeB $1 }
             | '*' CompoundType { AbsAuL.CompTypeP $2 }
             | BasicType ListBracks { AbsAuL.CompTypeA $1 $2 }
Bracks :: { Bracks }
Bracks : '[' ']' { AbsAuL.Brack }
ListBracks :: { [Bracks] }
ListBracks : Bracks { (:[]) $1 } | Bracks ListBracks { (:) $1 $2 }
Stm :: { Stm }
Stm : Decl ';' { AbsAuL.SDecl $1 }
    | Local ';' { AbsAuL.SLocal $1 }
    | Ass ';' { AbsAuL.SAss $1 }
    | While { AbsAuL.SWhile $1 }
    | Repeat ';' { AbsAuL.SRepeat $1 }
    | For { AbsAuL.SFor $1 }
    | If { AbsAuL.SIf $1 }
    | Func ';' { AbsAuL.SRExp $1 }
    | EBlk { AbsAuL.SEBlk $1 }
    | Return ';' { AbsAuL.SReturn $1 }
    | Break ';' { AbsAuL.SBreak $1 }
EBlk :: { EBlk }
EBlk : 'do' Block 'end' { AbsAuL.EBlkS $2 }
Decl :: { Decl }
Decl : BasicType LExp VarInit { AbsAuL.DeclSP $1 $2 $3 }
VarInit :: { VarInit }
VarInit : {- empty -} { AbsAuL.VarINil }
        | '=' RExp { AbsAuL.VarExp $2 }
        | '=' Array { AbsAuL.VarMat $2 }
Array :: { Array }
Array : '{' ListArray '}' { AbsAuL.ArrayV0 $2 }
      | '{' ListVType '}' { AbsAuL.ArrayV1 $2 }
VType :: { VType }
VType : Boolean { AbsAuL.VTypeBoolean $1 }
      | Char { AbsAuL.VTypeChar $1 }
      | Double { AbsAuL.VTypeDouble $1 }
      | Integer { AbsAuL.VTypeInteger $1 }
      | String { AbsAuL.VTypeString $1 }
      | PtrVoid { AbsAuL.VTypePtrVoid $1 }
ListVType :: { [VType] }
ListVType : VType { (:[]) $1 } | VType ',' ListVType { (:) $1 $3 }
ListArray :: { [Array] }
ListArray : Array { (:[]) $1 } | Array ',' ListArray { (:) $1 $3 }
Local :: { Local }
Local : 'local' Decl { AbsAuL.DeclLocal $2 }
Ass :: { Ass }
Ass : LExp '=' RExp { AbsAuL.AssD $1 $3 }
Func :: { Func }
Func : FuncWrite { AbsAuL.FuncBW $1 }
     | FuncRead { AbsAuL.FuncBR $1 }
     | LIdent '(' ListRExp ')' { AbsAuL.FnctCall $1 $3 }
FuncWrite :: { FuncWrite }
FuncWrite : 'writeInt' '(' RExp ')' { AbsAuL.WriteI $3 }
          | 'writeFloat' '(' RExp ')' { AbsAuL.WriteF $3 }
          | 'writeChar' '(' RExp ')' { AbsAuL.WriteC $3 }
          | 'writeString' '(' RExp ')' { AbsAuL.WriteS $3 }
FuncRead :: { FuncRead }
FuncRead : 'readInt' '(' ')' { AbsAuL.ReadI }
         | 'readFloat' '(' ')' { AbsAuL.ReadF }
         | 'readChar' '(' ')' { AbsAuL.ReadC }
         | 'readString' '(' ')' { AbsAuL.ReadS }
While :: { While }
While : 'while' RExp EBlk { AbsAuL.LoopW $2 $3 }
Repeat :: { Repeat }
Repeat : 'repeat' Block 'until' RExp { AbsAuL.LoopR $2 $4 }
For :: { For }
For : 'for' LIdent '=' RExp ',' RExp Increment EBlk { AbsAuL.LoopF $2 $4 $6 $7 $8 }
Increment :: { Increment }
Increment : {- empty -} { AbsAuL.FIncE }
          | ',' RExp { AbsAuL.FInc $2 }
If :: { If }
If : 'if' RExp 'then' Block ListElseIf Else 'end' { AbsAuL.IfM $2 $4 (reverse $5) $6 }
Else :: { Else }
Else : 'else' Block { AbsAuL.ElseS $2 }
     | {- empty -} { AbsAuL.ElseE }
ElseIf :: { ElseIf }
ElseIf : 'elseif' RExp 'then' Block { AbsAuL.ElseIfD $2 $4 }
ListElseIf :: { [ElseIf] }
ListElseIf : {- empty -} { [] }
           | ListElseIf ElseIf { flip (:) $1 $2 }
Return :: { Return }
Return : 'return' RValue { AbsAuL.JumpR $2 }
RValue :: { RValue }
RValue : {- empty -} { AbsAuL.JumpRE } | RExp { AbsAuL.JumpRV $1 }
Break :: { Break }
Break : 'break' { AbsAuL.JumpB }
ListRExp :: { [RExp] }
ListRExp : {- empty -} { [] }
         | RExp { (:[]) $1 }
         | RExp ',' ListRExp { (:) $1 $3 }
FuncD :: { FuncD }
FuncD : CompoundType 'function' LIdent '(' ListParamF ')' Block 'end' { AbsAuL.FnctDecl $1 $3 $5 $7 }
ParamF :: { ParamF }
ParamF : Modality BasicType LExp { AbsAuL.ParmDeclF $1 $2 $3 }
ListParamF :: { [ParamF] }
ListParamF : {- empty -} { [] }
           | ParamF { (:[]) $1 }
           | ParamF ',' ListParamF { (:) $1 $3 }
Modality :: { Modality }
Modality : {- empty -} { AbsAuL.Modality1 }
         | 'val' { AbsAuL.Modality_val }
         | 'const' { AbsAuL.Modality_const }
         | 'res' { AbsAuL.Modality_res }
         | 'valres' { AbsAuL.Modality_valres }
         | 'name' { AbsAuL.Modality_name }
LExp :: { LExp }
LExp : LIdent { AbsAuL.LExpS $1 }
     | '*' LExp { AbsAuL.LExpDR $2 }
     | LIdent ListDim { AbsAuL.LExpA $1 $2 }
ListDim :: { [Dim] }
ListDim : Dim { (:[]) $1 } | Dim ListDim { (:) $1 $2 }
Dim :: { Dim }
Dim : '[' RExp ']' { AbsAuL.Dims $2 }
RExp :: { RExp }
RExp : RExp1 '?' RExp1 ':' RExp1 { AbsAuL.IfT $1 $3 $5 }
     | RExp1 { $1 }
RExp1 :: { RExp }
RExp1 : RExp1 'or' RExp2 { AbsAuL.Or $1 $3 }
      | RExp2 'and' RExp3 { AbsAuL.And $1 $3 }
      | RExp2 { $1 }
RExp2 :: { RExp }
RExp2 : 'not' RExp4 { AbsAuL.Not $2 } | RExp3 { $1 }
RExp4 :: { RExp }
RExp4 : RExp5 '==' RExp5 { AbsAuL.Eq $1 $3 }
      | RExp5 '~=' RExp5 { AbsAuL.Neq $1 $3 }
      | RExp5 '<' RExp5 { AbsAuL.Lt $1 $3 }
      | RExp5 '<=' RExp5 { AbsAuL.LtE $1 $3 }
      | RExp5 '>' RExp5 { AbsAuL.Gt $1 $3 }
      | RExp5 '>=' RExp5 { AbsAuL.GtE $1 $3 }
      | RExp5 { $1 }
RExp6 :: { RExp }
RExp6 : RExp6 '+' RExp7 { AbsAuL.Add $1 $3 }
      | RExp6 '-' RExp7 { AbsAuL.Sub $1 $3 }
      | RExp7 { $1 }
RExp7 :: { RExp }
RExp7 : RExp7 '*' RExp8 { AbsAuL.Mul $1 $3 }
      | RExp7 '/' RExp8 { AbsAuL.Div $1 $3 }
      | RExp7 '%' RExp8 { AbsAuL.Rem $1 $3 }
      | RExp8 { $1 }
RExp8 :: { RExp }
RExp8 : RExp9 '^' RExp8 { AbsAuL.Pow $1 $3 } | RExp9 { $1 }
RExp9 :: { RExp }
RExp9 : '-' RExp10 { AbsAuL.Neg $2 } | RExp10 { $1 }
RExp10 :: { RExp }
RExp10 : Func { AbsAuL.FCall $1 }
       | RExp10 '..' RExp11 { AbsAuL.FStrCnt $1 $3 }
       | '#' RExp11 { AbsAuL.FLen $2 }
       | RExp11 { $1 }
RExp11 :: { RExp }
RExp11 : Integer { AbsAuL.ValInt $1 }
       | LExp { AbsAuL.ValVariable $1 }
       | '&' LExp { AbsAuL.ValRef $2 }
       | Double { AbsAuL.ValDouble $1 }
       | String { AbsAuL.ValString $1 }
       | Char { AbsAuL.ValChar $1 }
       | Boolean { AbsAuL.ValBoolean $1 }
       | PtrVoid { AbsAuL.ValPtr $1 }
       | RExp12 { $1 }
RExp3 :: { RExp }
RExp3 : RExp4 { $1 }
RExp5 :: { RExp }
RExp5 : RExp6 { $1 }
RExp12 :: { RExp }
RExp12 : '(' RExp ')' { $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

